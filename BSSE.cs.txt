
// TODO:
//	. cls() clear screen... clearscreen()?
//	+ keys($"Sorter") null reference exception
//	+ optional Vector math, vlen, dotproduct, crossproduct
//	+ optional matrix math, mmul, mdiv, minv

#region Visual Studio Setup

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
//using System.Linq.Expressions;
//using System.Net.NetworkInformation;
//using System.Runtime.CompilerServices;
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Security.Claims;
using System.Text;
//using System.Xml;
//using System.Xml.Linq;
//using Sandbox.Game.Entities;
//using Sandbox.Game.Entities.Blocks;
//using Sandbox.Game.World.Generator;
using Sandbox.ModAPI.Ingame;
using VRage;
using VRage.Game.GUI.TextPanel;
using VRage.Game.ModAPI.Ingame;
using Sandbox.ModAPI.Interfaces;
//using VRage.Game.ObjectBuilders;
//using VRage.Game.ObjectBuilders.Definitions;
using SpaceEngineers.Game.ModAPI.Ingame;
//using VRage.Game.Components;
using VRage.Game;
//using VRage.Game.VisualScripting.ScriptBuilder.Nodes;
//using Sandbox.ModAPI.Interfaces;
using VRageMath;

using ITerminalAction = Sandbox.ModAPI.Interfaces.ITerminalAction; // = ITerminalAction;
using ITerminalProperty = Sandbox.ModAPI.Interfaces.ITerminalProperty; // = ITerminalAction;

namespace BSSE
{
	class Program : MyGridProgram
	{
		#endregion // Visual Studio Setup


		#region Temp Junk
		void foo ()
		{
			//IGC
		}
		#endregion

		// START_CLIP

		#region Credits
		// BSS - Break Step Script interpreter for Space Engineers
		// By DFPercush 2020 - 2021
		// Donations welcome on ko-fi.com/DFPercush
		#endregion

		#region Help - Arguments
		/*
		Commands:
			run Button Panel 2
				Runs the script in Button Panel's custom data. Can be any type of block.

			on LCD Panel 2: run Button Panel 2;
				Runs the script in Button Panel 2's custom data,
				with print() function going to LCD Panel 2.
				The colon : is important.

			flush
				If AutoUnload is false, the status display will not be
				cleared of any finished items. This removes them.

			reset
				Hard reset, kill all scripts and come online fresh.
				Scripts will not get a signal of this.

			kill Argument
			kill My Block Name
				force-end the script as named on the status display

			suspend [name]
				Pauses the script as named on the status display

			resume [name]
				Resumes a suspended script.

		*/
		#endregion
		/*
		TODO:
			- Language / Syntax guide.
			- Default settings
			- print to lcd: 
				- Back buffer (multiple prints overwrite each other in same frame)
		*/
		// CONFIG

		const string StatusLcdName = "BSS-Status";
		// Like task manager

		const bool AutoUnload = true;
		// Unload a script when it ends (or crashes), clears from status screen.
		// If you want to see the status after things end, set to false.
		
		const bool ShowInternalErrs = true;

		const double CpuLoadFactor = 0.8;
		// Controls max instructions per frame.
		// Must be < 1 by a certain margin, or the
		// game will terminate this whole thing.

		//const int MaxFunctionCallParams = 20;
		// (Advanced - don't worry about it)
		// Safety to break infinite loops in case of bad calling convention.
		// The downside is that this will probably hide an underlying problem, but it won't hang.

		const bool EnableDebugPrint = true;
		const string DebugLcdName = "BSS-Debug";

		const int AverageCpuOverXFrames = 20;

		// Font to Surface scale factor. Small adjustment to avoid clipping characters off the edge of LCDs
		const float F2SX = 1.082f;
		const float F2SY = 1.0f;
		// END CONFIG
		//------------------------------------------------------
		// Code - Do not edit below here unless you are ub3r 1337

		//Debugging
		public static MyGridProgram g_prg = null;

		Scheduler sch = new Scheduler();
		//List<OWatch> blockWatches = new List<OWatch>();
		List<PWatch> propWatches = new List<PWatch>();
		public static IMyIntergridCommunicationSystem g_IGC = null;
		Program()
		{
			g_prg = this;
			g_IGC = IGC;
			Runtime.UpdateFrequency = UpdateFrequency.Update1;
			//initAccessors();
			if (Me.CustomData.Length == 0)
				Me.CustomData = "// Your init script here.\r\nprint(\"Hello from init script!\\r\\n(I'm in Custom Data.)\");";
			sch.Load(Me.CustomData, "init", new InitSys(this, null, propWatches));
			// TODO: Resume from save?
		}
		void Save() { }
		void Example()
		{
			dbgprint("Example:\r\non LCD Panel 1: run \"My Block\";\r\nThis will run the script in My Block's custom data, and any print() commands will go to LCD Panel 1.\r\nOtherwise, the argument is a script itself.");
		}
		int statusCycles = 0;
		int runCycles = 0;
		int pollCycles = 0;
		float cpu;
		int[] acpu = new int[AverageCpuOverXFrames];
		int iacpu = 0;
		int frn = 0; // frame number

		void Main(string arg, UpdateType updateSource)
		{
			sch.autoUnload = AutoUnload;
			switch (updateSource)
			{
				case UpdateType.Update1:
				case UpdateType.Update10:
				case UpdateType.Update100:
					// TODO: Update status LCD

					int startCycle = Runtime.CurrentInstructionCount;
					string ststr = "";
					try
					{
						var stlcd = GridTerminalSystem.GetBlockWithName(StatusLcdName) as IMyTextPanel;
						//stlcd.WriteText($"BreakStep script status\r\n{sch.RunnableCount} running, {sch.WaitingCount} waiting");
						ststr = $"BreakStep script status\r\n{sch.RunnableCount} running, {sch.WaitingCount} waiting\r\n";
						//ststr += $"Polling load {pollCycles * 100 / Runtime.MaxInstructionCount}%\r\n";
						//ststr += $"This display load {statusCycles * 100 / Runtime.MaxInstructionCount}%\r\n";

						acpu[iacpu] = (runCycles + pollCycles) * 100 / Runtime.MaxInstructionCount;
						cpu = 0;
						if (Runtime.UpdateFrequency == UpdateFrequency.Update1)
						{
							for (int ia = 0; ia < AverageCpuOverXFrames; ia++) { cpu += acpu[ia]; }
							cpu /= AverageCpuOverXFrames;
						}
						else cpu = acpu[iacpu];
						cpu = (float)Math.Round(cpu + 0.49);
						iacpu++;
						iacpu %= AverageCpuOverXFrames;
						ststr += $"CPU: Run {runCycles * 100 / Runtime.MaxInstructionCount}%, Poll {pollCycles * 100 / Runtime.MaxInstructionCount}%";
						var spinner = " " + "-\\|/"[(frn++ / 15) % 4] + "\n";
						ststr += spinner;
						foreach (var th in sch.ths)
						{
							ststr += $"{th.Status} {th.watches.Count}W {th.sourceName}\r\n";
							if (th.Status == Thread.State.TERM) continue;
							foreach (var wt in th.watches)
							{
								ststr += $"  {wt.Value.v.v.ty.ToString()} '{wt.Value.v.v.name}' " + (wt.Value.v.v.sy != null ? ":sy" : "") + "\n";
							}
						}
						stlcd.WriteText(ststr);
						var pbt = Me.GetSurface(0);
						//if (pbt.ContentType == VRage.Game.GUI.TextPanel.ContentType.NONE)
						//	pbt.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE;
						if (pbt.ContentType == ContentType.NONE)
							pbt.ContentType = ContentType.TEXT_AND_IMAGE;
						pbt.WriteText($"BSS\n{cpu}% cpu\n{spinner}");
					}
					catch { }

					statusCycles = Runtime.CurrentInstructionCount - startCycle;
					startCycle = Runtime.CurrentInstructionCount;

					// Poll watches

					// Blocks
					//for (int i = 0; i < blockWatches.Count; i++)
					//{
					//	// TODO: Should property changes affect the block?
					//	if (blockWatches[i].prev && GridTerminalSystem.GetBlockWithId(blockWatches[i].bcx.blockId) == null)
					//	{
					//		blockWatches[i].prev = false;
					//		blockWatches[i].v.assign(null);
					//	}
					//}

					// Properties
					for (int i = 0; i < propWatches.Count; i++)
					{
						PWatch pwi = propWatches[i];
						pwi.v.sy.read(pwi.v);
						
						////string sv;
						////VRageMath.Color cv;
						//long cvl;
						//float fv;
						//bool bv;
						//IMyTerminalBlock block = pwi.pcx.bcx.block;
						//string propname = pwi.pcx.propname;
						//switch (pwi.pcx.typename)
						//{
						//	case "string":
						//		// TODO: name
						//		break;
						//	case "Color":
						//		cvl = block.GetValueColor(propname).PackedValue;
						//		if (cvl > 0xFFFFFFFF)
						//		{
						//			dbgprint("Error: Colors work differently than I thought.");
						//		}
						//		if (pwi.prev != cvl) pwi.v.assign(cvl);
						//		break;
						//	case "float":
						//		fv = block.GetValueFloat(propname);
						//		if (!Var.feq(fv, pwi.v.num)) pwi.v.assign(fv);
						//		break;
						//	case "bool":
						//		bv = block.GetValueBool(propname);
						//		if (bv != pwi.v.tr) { pwi.v.assign(bv ? 1 : 0); }
						//		break;
						//}
						//// TODO:
						////block.CheckConnectionAllowed;
						////block.CustomData;
						////block. etc...
					}

					sch.CheckAllWatches();
					sch.CheckWake(); // Very important!
					sch.ReCountStates();

					pollCycles = Runtime.CurrentInstructionCount - startCycle;
					startCycle = Runtime.CurrentInstructionCount;

					// Continue scripts
					while ((Runtime.CurrentInstructionCount < Runtime.MaxInstructionCount * CpuLoadFactor) && sch.RunnableCount > 0)
					{
						sch.Step();
					}
					//if (sch.RunnableCount == 0 && sch.WaitingCount == 0) Runtime.UpdateFrequency = UpdateFrequency.Update10;
					//else { Runtime.UpdateFrequency = UpdateFrequency.Update1; }
					runCycles = Runtime.CurrentInstructionCount - startCycle;
					break;

				default:
					// Run argument
					Echo("RUN");
					if (EnableDebugPrint) Echo("COMMAND");
					if (arg == "flush")
					{


						//if (EnableDebugPrint) Echo("yviq");


						for (int i = 0; i < sch.ths.Count; i++)
						{
							if (sch.ths[i].Status == Thread.State.ERR || sch.ths[i].Status == Thread.State.TERM)
							{
								sch.ths.RemoveAt(i);
								i--;
							}
						}


						//if (EnableDebugPrint) Echo("fuqw");


						sch.ReCountStates();
						return;
					}
					else if (arg == "unload")
					{
						sch = null;
						sch = new Scheduler();
						sch.showInternalErrs = ShowInternalErrs;
						return;
					}
					else if (arg.Length > 5 && arg.Substring(0, 5) == "kill ")
					{
						string killName = arg.Substring(5).Trim();
						if (killName[0] == '\"' && killName.Length > 2) killName = killName.Substring(1, killName.Length - 2);
						for (int iPropWatch = 0; iPropWatch < propWatches.Count; iPropWatch++)// (var pw in propWatches)
						{
							var pw = propWatches[iPropWatch];
							try
							{
								//if (pw.pcx.bcx.sys.th.sourceName == killName)
								if (pw.th.sourceName == killName)
								{
									propWatches.RemoveAt(iPropWatch);
									iPropWatch--;
								}
							}
							catch (Exception err) { Echo("Warning: while cleaning up watches: " + err.Message); }
						}
						//for (int iBlockWatch = 0; iBlockWatch < blockWatches.Count; iBlockWatch++)
						//{
						//	var bw = blockWatches[iBlockWatch];
						//	try
						//	{
						//		if (bw.bcx.sys.th.sourceName == killName)
						//		{
						//			blockWatches.RemoveAt(iBlockWatch);
						//			iBlockWatch--;
						//		}
						//	}
						//	catch (Exception err) { Echo("Warning: while cleaning up block watches: " + err.Message); }
						//}
						sch.Kill(arg.Substring(5).Trim());
						return;
					}
					else if (arg.Length > 8 && arg.Substring(0, 8) == "suspend ")
					{
						sch.Suspend(arg.Substring(8).Trim());
						return;
					}
					else if (arg.Length > 7 && arg.Substring(0, 7) == "resume ")
					{
						sch.Resume(arg.Substring(7).Trim());
					}
					//else if (arg)


					if (EnableDebugPrint) Echo("stge");


					IMyTextPanel con = null;
					if (arg.Length < 3) { Example(); return; }
					int iCol = arg.IndexOf(":");
					if (arg.Substring(0, 3).ToLower() == "on ")
					{


						if (EnableDebugPrint) { Echo("vbje"); }


						if (iCol == -1) { dbgprint("Syntax error."); Example(); return; }
						string consoleName = arg.Substring(3, iCol - 3).Trim();
						con = GridTerminalSystem.GetBlockWithName(consoleName) as IMyTextPanel;


						if (EnableDebugPrint) { Echo("zdfh"); }


						if (con == null && consoleName[0] == '\"' && consoleName[consoleName.Length - 1] == '\"')
						{
							consoleName = consoleName.Substring(1, consoleName.Length - 2);
							con = GridTerminalSystem.GetBlockWithName(consoleName) as IMyTextPanel;
						}


						if (EnableDebugPrint) { Echo("isdf"); }


						if (con == null)
						{
							dbgprint($"Text panel {consoleName} was not found. Aborting."); Example(); return;
						}
						con.WriteText(" \n", false);
					}


					if (EnableDebugPrint) { Echo("sdgp"); }


					string loadmsg = DateTime.Now.TimeOfDay.ToString() + "Loading";
					if (con != null) loadmsg += " on " + con.CustomName;
					dbgprint(loadmsg);


					if (EnableDebugPrint) { Echo("mtgh"); }


					var sy = new BSGridSystem(this, con, propWatches);
					sy.EnableDebugPrint = EnableDebugPrint;


					if (EnableDebugPrint) { Echo("gsdn"); }

					sch.Load(arg.Substring(iCol + 1), "Argument", sy);


					if (EnableDebugPrint) { Echo("dghb"); }


					Runtime.UpdateFrequency = UpdateFrequency.Update1;
					break;
			} // switch update type
		} // Main()

		void dbgprint(string s)
		{
			var b = GridTerminalSystem.GetBlockWithName(DebugLcdName) as IMyTextPanel;
			if (b != null)
			{
				b.WriteText(s);
			}
			Echo(s);
		}

		//class OWatch
		//{
		//	static int next_id = 1;
		//	public int id = next_id++;
		//	public Var v;
		//	public object ob;
		//	public bool prev;
		//	public OWatch(object ob_p, Var vp)
		//	{
		//		ob = ob_p;
		//		v = vp;
		//		prev = true;
		//	}
		//}

		// Property watch
		class PWatch
		{
			static long next_id = 1;
			public long id = next_id++;
			public Var v;
			public Var prev;
			public Thread th;
			//public PCX pcx;
			//public BlockPropWatch(PCX pcx_p, Var vp)
			public PWatch(Var v_p, Thread th_p)
			{
				v = v_p;
				prev = new Var(v_p);
				th = th_p;
				//pcx = pcx_p;
			}
		}

		class BSGridSystem : ISystem
		{
			public MyGridProgram m_prg;
			//string LcdName = "";
			public IMyTextPanel console;
			public Thread th;
			//public Dictionary<int, BlockWatch> blockWatches;
			//public Dictionary<int, BlockPropWatch> propWatches;
			//public List<OWatch> blockWatches;
			public List<PWatch> propWatches;

			public BSGridSystem(MyGridProgram p_prg, IMyTextPanel p_console, List<PWatch> propWatches_p)
			{
				m_prg = p_prg;
				console = p_console;
				//blockWatches = blockWatches_p;
				propWatches = propWatches_p;
			}

			// Block Context
			public class BCX
			{
				public IMyTerminalBlock b = null;
				public BSGridSystem sys;
				public BCX(IMyTerminalBlock p_b, BSGridSystem p_sys)
				{
					b = p_b;
					sys = p_sys;
				}
				private BCX() { }
			}

			void ISystem.InitScope(Thread th_p, Dictionary<string, Var> sc)
			{
				MyInitScope(th_p, sc);
			}

			public Var s_print(object cx, List<Var> args)
			{
				var me = cx as BSGridSystem;
				string ln = "";
				foreach (var a in args)
				{
					//pthis.console.WriteText(a.str, true);
					ln += a.str;
				}
				bool L = false;
				#region print() to LCD
				L = true;
				#endregion
				if (L)
				{
					#region print() to LCD
					print(me.console, ln);
					#endregion
				}
				else
				{
					m_prg.Echo(ln);
				}
				return ln;
			}
			public Var s_printLn(object x, List<Var> args)
			{
				var r = s_print(x, args);
				r += s_print(x, new List<Var> { "\n" });
				return r;
			}
			public virtual void MyInitScope(Thread th_p, Dictionary<string, Var> sc)
			{
				th = th_p;
				sc["newline"] = "\n";
				sc["newLine"] = "\n";
				//sc["print"] = SysVar.mkFunction(th, "print", this, print_v);
				sc["print"] = SysVar.mkfn(th, "print", this, s_print);
				sc["println"] = SysVar.mkfn(th, "println", this, s_printLn);
				sc["printLine"] = SysVar.mkfn(th, "printLine", this, s_printLn);

				#region Vector Math
				sc["vlen"] = SysVar.mkfn(th, "vlen", this, (object cx, List<Var> a) => Math.Sqrt((a[0]["X"] * a[0]["X"]) + (a[0]["Y"] * a[0]["Y"]) + (a[0]["Z"].num * a[0]["Z"].num)));
				sc["dotproduct"] = SysVar.mkfn(th, "dotproduct", this, (object cx, List<Var> a) => (a[0]["X"] * a[1]["X"]) + (a[0]["Y"] * a[1]["Y"]) + (a[0]["Z"].num * a[1]["Z"].num));
				sc["crossproduct"] = SysVar.mkfn(th, "crossproduct", this, (object cx, List<Var> a) =>
				{
					Var r = th.mkv('a');
					r["X"] = (a[0]["Y"] * a[1]["Z"]) - (a[0]["Z"] * a[1]["Y"]);
					r["Y"] = (a[0]["Z"] * a[1]["X"]) - (a[0]["X"] * a[1]["Z"]);
					r["Z"] = (a[0]["X"] * a[1]["Y"]) - (a[0]["Y"] * a[1]["X"]);
					return r;
				});
				#endregion

				#region Matrix Math
				sc["mmul"] = SysVar.mkfn(th, "mmul", this, (object cx, List<Var> a) =>
				{
					if (a[1].d.ContainsKey("X")) return vVec(mmulv(v2Mat(a[0]), v2vec(a[1])));
					return vMat(v2Mat(a[0]) * v2Mat(a[1]));
				});
				sc["mdiv"] = SysVar.mkfn(th, "mdiv", this, (object cx, List<Var> a) => vMat(v2Mat(a[0]) * minv(v2Mat(a[1]))));
				sc["minv"] = SysVar.mkfn(th, "minv", this, (object cx, List<Var> a) => vMat(minv(v2Mat(a[0]))));
				sc["morientation"] = SysVar.mkfn(th, "orientation", this, (object cx, List<Var> a) => vMat(v2Mat(a[0]).GetOrientation()));
				sc["midentity"] = SysVar.mkfn(th, "", this, (object cx, List<Var> a) => vMat(MatrixD.Identity));
				sc["mrotate"] = SysVar.mkfn(th, "mrotate", this, (object cx, List<Var> a) => vMat(mrot(v2vec(a[0]), a[1])));
				sc["mtranslate"] = SysVar.mkfn(th, "", this, (object cx, List<Var> a) => vMat(mtran(v2vec(a[0]))));
				sc["mscale"] = SysVar.mkfn(th, "", this, (object cx, List<Var> a) => vMat(mscale(v2vec(a[0]))));
				#endregion

				//sc[""] = SysVar.mkfn(th, "", this, (object cx, List<Var> a) =>);

			}

			public bool EnableDebugPrint = true;
			//void dbgprv(string msg)
			//{
			//	if (!EnableDebugPrint) return;
			//	Var pr = th.fv("print");
			//	if (pr == null) return;
			//	th.pushv(pr);
			//	th.pushv(msg);
			//	print_v(pr);
			//}
			Ref ISystem.Resolve(Thread th, Var vp)
			{
				var g = m_prg.GridTerminalSystem;
				List<IMyTerminalBlock> bs = new List<IMyTerminalBlock>();
				if (vp.ty == 's')
				{
					if (vp == "IGC")
					{
						Var cm = SysVar.New(g_IGC, th);
						//if (g_IGC == null) print(console, "IGC null!");
						//print(console, $"Resolve: IGC id {(cm.sy.cx as IMyIntergridCommunicationSystem).Me}");
						sIGCS(cm.sy);
						return cm;
					}

					var grp = g.GetBlockGroupWithName(vp.str);
					if (grp != null)
					{
						//Var a = vp.th.mkv('a', vp.str);
						Var a = th.mkv('a', vp.str);
						var blocks = new List<IMyTerminalBlock>();
						grp.GetBlocks(blocks);
						foreach (var b in blocks)
						{
							a.d[b.CustomName] = vBlock(b);
						}
						a.sy = new SysVar(this);
						a.sy.readIndex = (Var v, Var idx) =>
						{
							// You can't read a single value for a whole group.
							return th.mkv('0');
						};
						a.sy.assignIndex = (Var v, Var idx, Var val) =>
						{
							foreach (var bv in v.d.Values)
							{
								bv[idx] = val;
							}
						};
						return a;
					}

					var block = g.GetBlockWithName(vp.str);
					if (block != null)
					{
						//Ref ret = new Ref(mkBlockRef(block));
						Ref ret = new Ref(vBlock(block));
						ret.xr = true;
						return ret;
					}
				}
				return null;
			}

			#region Production Blocks
			IMyAssembler Ass(object cx) { return (cx as BCX).b as IMyAssembler; }
			#endregion
			#region Battery
			IMyBatteryBlock BB(object cx) { return (cx as BCX).b as IMyBatteryBlock; }
			#endregion
			#region Beacon
			IMyBeacon Bea(object cx) { return (cx as BCX).b as IMyBeacon; }
			#endregion
			IMyBlockGroup BG(object cx) { return (cx as BCX).b as IMyBlockGroup; }
			#region Camera
			IMyCameraBlock Cam(object cx) { return (cx as BCX).b as IMyCameraBlock; }
			#endregion
			#region Inventory
			IMyCargoContainer CC(object cx) { return (cx as BCX).b as IMyCargoContainer; }
			#endregion
			#region Cockpit
			IMyCockpit Coc(object cx) { return (cx as BCX).b as IMyCockpit; }
			#endregion
			#region Collector
			IMyCollector Col(object cx) { return (cx as BCX).b as IMyCollector; }
			#endregion
			#region Conveyor
			IMyConveyor Conv(object cx) { return (cx as BCX).b as IMyConveyor; }
			#region Sorter
			IMyConveyorSorter CS(object cx) { return (cx as BCX).b as IMyConveyorSorter; }
			#endregion
			IMyConveyorTube CT(object cx) { return (cx as BCX).b as IMyConveyorTube; }
			#endregion
			#region Cryo Chamber
			IMyCryoChamber Cry(object cx) { return (cx as BCX).b as IMyCryoChamber; }
			#endregion
			//#region Decoy
			//IMyDecoy Dec(object cx) { return (cx as BCX).b as IMyDecoy; }
			//#endregion
			#region Doors
			IMyDoor Door(object cx) { return (cx as BCX).b as IMyDoor; }
			#endregion
			#region Piston
			IMyExtendedPistonBase EPB(object cx) { return (cx as BCX).b as IMyExtendedPistonBase; }
			#endregion
			IMyFunctionalBlock FB(object cx) { return (cx as BCX).b as IMyFunctionalBlock; }
			#region Gas Generator
			IMyGasGenerator GG(object cx) { return (cx as BCX).b as IMyGasGenerator; }
			#endregion
			#region Gas Tank
			IMyGasTank GT(object cx) { return (cx as BCX).b as IMyGasTank; }
			#endregion
			#region Gyro
			IMyGyro Gyr(object cx) { return (cx as BCX).b as IMyGyro; }
			#endregion
			#region Comms
			IMyIntergridCommunicationSystem IGCS(object cx) { return cx as IMyIntergridCommunicationSystem; }
			#endregion
			#region Jump Drive
			IMyJumpDrive JD(object cx) { return (cx as BCX).b as IMyJumpDrive; }
			#endregion
			#region Turrets
			IMyLargeTurretBase LTB(object cx) { return (cx as BCX).b as IMyLargeTurretBase; }
			#endregion
			#region Antenna
			IMyLaserAntenna LA(object cx) { return (cx as BCX).b as IMyLaserAntenna; }
			#endregion
			#region Lights
			IMyLightingBlock LB(object cx) { return (cx as BCX).b as IMyLightingBlock; }
			#endregion
			#region Attachable Blocks
			IMyMechanicalConnectionBlock MCB(object cx) { return (cx as BCX).b as IMyMechanicalConnectionBlock; }
			#region Rotors
			IMyMotorAdvancedRotor MAR(object cx) { return (cx as BCX).b as IMyMotorAdvancedRotor; }
			IMyMotorAdvancedStator MAS(object cx) { return (cx as BCX).b as IMyMotorAdvancedStator; }
			IMyMotorBase MB(object cx) { return (cx as BCX).b as IMyMotorBase; }
			IMyMotorRotor MR(object cx) { return (cx as BCX).b as IMyMotorRotor; }
			IMyMotorStator MSta(object cx) { return (cx as BCX).b as IMyMotorStator; }
			#endregion
			#region Wheel Suspension
			IMyMotorSuspension MSus(object cx) { return (cx as BCX).b as IMyMotorSuspension; }
			#endregion
			#endregion // Attachable Blocks
			#region Ore Detector
			IMyOreDetector OD(object cx) { return (cx as BCX).b as IMyOreDetector; }
			#endregion
			//IMyOxygenGenerator OG(object cx) { return (cx as BCX).b as IMyOxygenGenerator;}
			//IMyOxygenTank OT(object cx) { return (cx as BCX).b as IMyOxygenTank;}
			//#region Passage
			//IMyPassage Pas(object cx) { return (cx as BCX).b as IMyPassage; }
			//#endregion
			#region Piston
			IMyPistonBase PisB(object cx) { return (cx as BCX).b as IMyPistonBase; }
			IMyPistonTop PisT(object cx) { return (cx as BCX).b as IMyPistonTop; }
			#endregion
			#region Power Producers
			IMyPowerProducer PP(object cx) { return (cx as BCX).b as IMyPowerProducer; }
			#endregion
			#region Production Blocks
			IMyProductionBlock Prod(object cx) { return (cx as BCX).b as IMyProductionBlock; }
			#endregion
			#region Programmable Block
			IMyProgrammableBlock PB(object cx) { return (cx as BCX).b as IMyProgrammableBlock; }
			#endregion
			#region Projector
			IMyProjector Proj(object cx) { return (cx as BCX).b as IMyProjector; }
			#endregion
			#region Antenna
			IMyRadioAntenna RA(object cx) { return (cx as BCX).b as IMyRadioAntenna; }
			#endregion
			#region Reactor
			IMyReactor Rea(object cx) { return (cx as BCX).b as IMyReactor; }
			#endregion
			#region Production Blocks
			IMyRefinery Refi(object cx) { return (cx as BCX).b as IMyRefinery; }
			#endregion
			#region Lights
			//IMyReflectorLight RL(object cx) { return (cx as BCX).b as IMyReflectorLight; }
			#endregion
			#region Remote Control
			IMyRemoteControl RC(object cx) { return (cx as BCX).b as IMyRemoteControl; }
			#endregion
			#region Sensor
			IMySensorBlock Sen(object cx) { return (cx as BCX).b as IMySensorBlock; }
			#endregion
			#region Connector
			IMyShipConnector SConn(object cx) { return (cx as BCX).b as IMyShipConnector; }
			#endregion
			#region Ship Controller
			IMyShipController SCtl(object cx) { return (cx as BCX).b as IMyShipController; }
			#endregion
			#region Ship Tools
			IMyShipDrill SDri(object cx) { return (cx as BCX).b as IMyShipDrill; }
			IMyShipGrinder SGri(object cx) { return (cx as BCX).b as IMyShipGrinder; }
			IMyShipWelder SWel(object cx) { return (cx as BCX).b as IMyShipWelder; }
			IMyShipToolBase STB(object cx) { return (cx as BCX).b as IMyShipToolBase; }
			#endregion // Ship Tools
			#region Guns
			IMySmallGatlingGun SGG(object cx) { return (cx as BCX).b as IMySmallGatlingGun; }
			#endregion
			#region Missiles
			IMySmallMissileLauncher SML(object cx) { return (cx as BCX).b as IMySmallMissileLauncher; }
			IMySmallMissileLauncherReload SMLR(object cx) { return (cx as BCX).b as IMySmallMissileLauncherReload; }
			#endregion
			#region Store Block
			IMyStoreBlock Sto(object cx) { return (cx as BCX).b as IMyStoreBlock; }
			#endregion


			IMyTerminalBlock TB(object cx) { return (cx as BCX).b as IMyTerminalBlock; }


			#region Text
			IMyTextPanel TP(object cx) { return (cx as BCX).b as IMyTextPanel; }
			#endregion
			#region Upgrades
			IMyUpgradableBlock UB(object cx) { return (cx as BCX).b as IMyUpgradableBlock; }
			IMyUpgradeModule UM(object cx) { return (cx as BCX).b as IMyUpgradeModule; }
			#endregion
			#region Guns
			IMyUserControllableGun UCG(object cx) { return (cx as BCX).b as IMyUserControllableGun; }
			#endregion
			#region Warhead
			IMyWarhead War(object cx) { return (cx as BCX).b as IMyWarhead; }
			#endregion
			#region Wheels
			IMyWheel Whe(object cx) { return (cx as BCX).b as IMyWheel; }
			#endregion

			// Add Property
			void ap(SysVar sv, string name, SysVar.PropertyGetFn get, SysVar.PropertySetFn set = null)
			{
				sv.AddProp(name, get, set);
			}
			void am(SysVar sv, string name, SysVar.Method m)
			{
				sv.AddMethod(name, m);
			}
			Var vBlock(IMyTerminalBlock b)
			{
				BCX bcx = new BCX(b, this);
				Var r = SysVar.New(bcx, th);
				sBlk(r.sy, b);
				return r;
			}
			void sBlk(SysVar s, IMyTerminalBlock blk)
			{
				// Local function not allows - C# 6
				//// Add Property - use implicit local arg sv to save space
				//void ap(string name, SysVar.PropertyGetFn get, SysVar.PropertySetFn set = null)
				//{
				//	s.AddProp(name, get, set);
				//}
				//void am(string name, SysVar.Method m)
				//{
				//	s.AddMethod(name, m);
				//}

				// All terminal blocks are functional blocks
				sFB(s);

				#region Block/Item Definitions
				ap(s, "BlockDefinition", (object x) => vDef(TB(x).BlockDefinition));
				#endregion
				ap(s, "DefinitionDisplayNameText", (object x) => TB(x).DefinitionDisplayNameText);
				//ap(s, "", (object x) => TB(x).);

				// BLOCK PROPERTY IMPLEMENTATIONS
				ap(s, "CheckConnectionAllowed", (object x) => TB(x).CheckConnectionAllowed);
				#region Components
				//ap("Components", (object x) =>
				//{
				//	// TODO: low priority
				//	var b = TB(x);
				//	//b.Components
				//	var cts = b.Components.GetComponentTypes();
				//	cts.ForEach((ct) =>
				//	{
				//		//ct.Name
				//		b.Components.Get();
				//	});
				//}, null);
				#endregion //Components
				#region Cube Grid
				ap(s, "CubeGrid", (object x) => vCubeGrid(TB(x).CubeGrid));
				#endregion

				ap(s, "CustomData", (object x) => TB(x).CustomData, (object x, Var v) => TB(x).CustomData = v);
				ap(s, "CustomInfo", (object x) => TB(x).CustomInfo);
				ap(s, "CustomName", (object x) => TB(x).CustomName, (object x, Var v) => TB(x).CustomName = v);
				ap(s, "CustomNameWithFaction", (object x) => TB(x).CustomNameWithFaction);
				ap(s, "DefinitionDisplayNameText", (object x) => TB(x).DefinitionDisplayNameText);
				ap(s, "DetailedInfo", (object x) => TB(x).DetailedInfo);
				ap(s, "DisassembleRatio", (object x) => TB(x).DisassembleRatio);
				ap(s, "DisplayName", (object x) => TB(x).DisplayName);
				ap(s, "DisplayNameText", (object x) => TB(x).DisplayNameText);
				ap(s, "EntityId", (object x) => TB(x).EntityId);
				ap(s, "HasInventory", (object x) => TB(x).HasInventory);
				ap(s, "InventoryCount", (object x) => TB(x).InventoryCount);
				ap(s, "IsBeingHacked", (object x) => TB(x).IsBeingHacked);
				ap(s, "IsFunctional", (object x) => TB(x).IsFunctional);
				ap(s, "IsWorking", (object x) => TB(x).IsWorking);
				ap(s, "Mass", (object x) => TB(x).Mass);
				ap(s, "Name", (object x) => TB(x).Name);
				ap(s, "NumberInGrid", (object x) => TB(x).NumberInGrid);
				ap(s, "OwnerId", (object x) => TB(x).OwnerId);
				ap(s, "ShowInInventory", (object x) => TB(x).ShowInInventory, (object x, Var v) => TB(x).ShowInInventory = v);
				ap(s, "ShowInTerminal", (object x) => TB(x).ShowInTerminal, (object x, Var v) => TB(x).ShowInTerminal = v);
				ap(s, "ShowInToolbarConfig", (object x) => TB(x).ShowInToolbarConfig, (object x, Var v) => TB(x).ShowInToolbarConfig = v);
				ap(s, "ShowOnHUD", (object x) => TB(x).ShowOnHUD, (object x, Var v) => TB(x).ShowOnHUD = v);
				#region Geometry
				ap(s, "Orientation", (object x) => vBlockOrientation(TB(x).Orientation));
				ap(s, "Position", (object x) => vVec(TB(x).Position));
				ap(s, "Max", (object x) => vVec(TB(x).Max));
				ap(s, "Min", (object x) => vVec(TB(x).Min));
				ap(s, "WorldAABB", (object x) => vAABB(TB(x).WorldAABB));
				ap(s, "WorldAABBHr", (object x) => vAABB(TB(x).WorldAABBHr));
				ap(s, "WorldMatrix", (object x) => vMat(TB(x).WorldMatrix));
				ap(s, "WorldVolume", (object x) => vBoundingSphere(TB(x).WorldVolume));
				ap(s, "WorldVolumeHr", (object x) => vBoundingSphere(TB(x).WorldVolumeHr));
				#endregion //Geometry

				ap(s, "Type", (object x) => TB(x).GetType().Name);

				//Template
				//ap(s, "", (object x) => TB(x)., (object x, Var v) => TB(x). = v);

				am(s, "ApplyAction", (object x, List<Var> args) => { (x as BCX).b.ApplyAction(args[0]); return null; });
				am(s, "GetActions", (object x, List<Var> args) =>
				{
					var b = (x as BCX).b;
					var acs = new List<ITerminalAction>();
					b.GetActions(acs);
					Var r = th.mkv('a');
					int i = 0;
					foreach (var a in acs) { r[i++] = a.Name.ToString(); }
					return r;
				});
				am(s, "GetDefaultValue", (object x, List<Var> args) =>
				{
					var b = (x as BCX).b;
					var p = b.GetProperty(args[0]);
					switch (p.TypeName)
					{
						case "bool":
							return b.GetDefaultValue<bool>(args[0]);
						case "float":
							return b.GetDefaultValue<float>(args[0]);
						case "color":
						case "Color":
							Color c = b.GetDefaultValue<Color>(args[0]);
							return c.PackedValue;
					}
					return null;
				});
				// TODO: Do we need an exact 64 bit int type in Var?
				am(s, "GetId", (object x, List<Var> args) => { return (x as BCX).b.GetId(); });

				#region Inventory
				// <comp name="Inventory Items">
				am(s, "GetInventory", (object x, List<Var> a) =>
				{
					if (a.Count > 0) return vInv((x as BCX).b.GetInventory((int)a[0]));
					return vInv((x as BCX).b.GetInventory());
				});

				// OBSOLETE, throws warning
				// am(s, "GetInventoryCount", (object x, List<Var> args) => (x as BCX).b.GetInventoryCount());

				// </comp> Inventory Items
				#endregion //Inventory

				am(s, "GetMaximum", (object x, List<Var> a) => (x as BCX).b.GetMaximum<float>(a[0].str));
				am(s, "GetMinimum", (object x, List<Var> a) => (x as BCX).b.GetMinimum<float>(a[0].str));
				am(s, "GetOwnerFactionTag", (object x, List<Var> a) => (x as BCX).b.GetOwnerFactionTag());

				// NOT ACCESSIBLE IN GAME - ModAPI.IMyCubeBlock Only
				// am(s, "GetPlayerRelationToOwner", (object x, List<Var> a) => (x as BCX).b.GetPlayerRelationToOwner().ToString());

				#region Geometry
				am(s, "GetPosition", (object x, List<Var> a) => vVec((x as BCX).b.GetPosition()));
				#endregion
				am(s, "GetProperties", (object x, List<Var> a) =>
				{
					var ram = th.mkv('a');
					var l = new List<ITerminalProperty>();
					(x as BCX).b.GetProperties(l);
					foreach (var p in l) ram.a.Add(p.Id);
					return ram;
				});
				// You might be looking for GetValue()
				//am("GetProperty", (object x, List<Var> a) =>
				//{
				//	var b = (x as BCX).b;
				//	var p = b.GetProperty(a[0].str);
				//	switch (p.TypeName)
				//	{
				//		case "bool":
				//			return p.
				//		case "float":
				//		case "color":
				//		case "Color":
				//	}
				//});

				// Obsolete, throws warning
				//am(s, "GetUseConveyorSystem", (object x, List<Var> a) => (x as BCX).b.GetUseConveyorSystem());


				am(s, "GetUserRelationToOwner", (object x, List<Var> a) => (x as BCX).b.GetUserRelationToOwner((long)a[0]).ToString());
				am(s, "GetValue", (object x, List<Var> a) =>
				{
					var b = (x as BCX).b;
					var p = b.GetProperty(a[0].str);
					var n = a[0].str; // name of property
					switch (p.TypeName)
					{
						case "bool":
							return b.GetValueBool(n);
						case "float":
							return b.GetValueFloat(n);
						case "color":
						case "Color":
							return b.GetValueColor(n).PackedValue;
					}
					return null;
				});
				am(s, "HasAction", (object x, List<Var> a) => (x as BCX).b.HasAction(a[0].str));
				am(s, "HasLocalPlayerAccess", (object x, List<Var> a) => (x as BCX).b.HasLocalPlayerAccess());
				am(s, "HasPlayerAccess", (object x, List<Var> a) => (x as BCX).b.HasPlayerAccess((long)a[0]));
				am(s, "IsSameConstructAs", (object x, List<Var> a) => (x as BCX).b.IsSameConstructAs(TB(a[0].sy.cx)));
				am(s, "SearchActionsOfName", (object x, List<Var> a) =>
				{
					Var ram = th.mkv('a');
					var b = (x as BCX).b;
					var l = new List<ITerminalAction>();
					b.SearchActionsOfName(a[0], l);
					foreach (var ac in l) ram.a.Add(ac.Id);
					return ram;
				});

				// Obsolete, throws warning
				// am(s, "SetCustomName", (object x, List<Var> a) => { (x as BCX).b.SetCustomName(a[0]); return null; });
				// same
				//am(s, "SetUseConveyorSystem", (object x, List<Var> a) => { (x as BCX).b.SetUseConveyorSystem(a[0].tr); return null; });

				am(s, "SetValue", (object x, List<Var> a) =>
				{
					var b = (x as BCX).b;
					var p = b.GetProperty(a[0].str);
					var n = a[0].str; // name of property
					switch (p.TypeName)
					{
						case "bool":
							b.SetValueBool(n, a[1].tr);
							break;
						case "float":
							b.SetValueFloat(n, (float)a[1]);
							break;
						case "color":
						case "Color":
							b.SetValueColor(n, new Color((uint)a[1].num));
							break;
					}
					return null;
				});

				// Obsolete, throws warning
				// am(s, "UpdateIsWorking", (object x, List<Var> a) => { (x as BCX).b.UpdateIsWorking(); return null; });
				//am(s, "UpdateVisual", (object x, List<Var> a) => { (x as BCX).b.UpdateVisual(); return null; });

				// Template
				//am("", (object x, List<Var> a) =>{ var b = (x as BCX).b;  return null; });



				switch (blk.GetType().Name)
				{
					#region Doors
					case "MyDoor":
						sDoor(s);
						break;
					case "MyAdvancedDoor":
						sAD(s);
						break;
					case "MyAirtightDoorBase":
						sADB(s);
						break;
					case "MyAirtightHangarDoor":
						sAHD(s);
						break;
					case "MyAirtightSlideDoor":
						sASD(s);
						break;
					#endregion //Doors
					#region Production Blocks
					case "MyAssembler":
						sAss(s);
						break;
					#endregion //Production Blocks
					#region Attachable Blocks
					case "MyAttachableTopBlock":
						sATB(s);
						break;
					#endregion // Attachable Blocks
					#region Battery
					case "MyBatteryBlock":
						sBB(s);
						break;
					#endregion // Battery
					#region Beacon
					case "MyBeacon":
						sBea(s);
						break;
					#endregion
					//case "MyBlockGroup":
					//	break;
					#region Antenna
					#region Comms
					case "MyBroadcastListener":
						sBL(s);
						break;
					#endregion // Comms
					#endregion // Antenna
					#region Camera
					case "MyCameraBlock":
						sCam(s);
						break;
					#endregion
					#region Inventory
					case "MyCargoContainer":
						sCC(s);
						break;
					#endregion //Inventory
					#region Cockpit
					case "MyCockpit":
						sCoc(s);
						break;
					#endregion
					#region Collector
					case "MyCollector":
						sCol(s);
						break;
					#endregion
					#region Conveyor
					case "MyConveyor":
						sConv(s);
						break;
					#region Sorter
					case "MyConveyorSorter":
						sCS(s);
						break;
					#endregion // Sorter
					case "MyConveyorTube":
						sCT(s);
						break;
					#endregion // Conveyor
					#region Cryo Chamber
					case "MyCryoChamber":
						sCry(s);
						break;
					#endregion
					//#region Decoy
					//case "MyDecoy":
					// Doesn't do anything
					//	sDec(s);
					//	break;
					//#endregion
					#region Piston
					case "MyExtendedPistonBase":
						sEPB(s);
						break;
					#endregion

					// This is required by everything
					case "MyFunctionalBlock":
						sFB(s);
						break;

					#region Gas Generator
					case "MyGasGenerator": // O2/H2 Generator in UI
						sGG(s);
						break;
					#endregion
					#region Gas Tank
					case "MyGasTank":
						sGT(s);
						break;
					#endregion
					//case "MyGridProgramRuntimeInfo":
					//	sGPRI(sv);
					//	break;
					//case "MyGridTerminalSystem":
					//	sGTS(sv);
					//	break;
					#region Gyro
					case "MyGyro":
						sGyr(s);
						break;
					#endregion // Gyro

					#region Comms
					case "MyIntergridCommunicationSystem":
						sIGCS(s);
						break;
					#endregion

					#region Jump Drive
					case "MyJumpDrive":
						sJD(s);
						break;
					#endregion
					#region Turrets
					case "MyLargeTurretBase":
						sLTB(s);
						break;
					#endregion
					#region Antenna
					case "MyLaserAntenna":
						sLA(s);
						break;
					#endregion
					#region Lights
					case "MyLightingBlock":
						sLB(s);
						break;
					#endregion
					#region Comms
					case "MyMessageProvider":
						sMP(s);
						break;
					#endregion
					#region Attachable Blocks
					case "MyMechanicalConnectionBlock":
						sMCB(s);
						break;
					#region Rotors
					case "MyMotorAdvancedRotor":
						sMAR(s);
						break;
					case "MyMotorAdvancedStator":
						sMAS(s);
						break;
					case "MyMotorBase":
						sMB(s);
						break;
					case "MyMotorRotor":
						sMR(s);
						break;
					case "MyMotorStator":
						sMSta(s);
						break;
					#endregion //Rotors
					#region Wheel Suspension
					case "MyMotorSuspension":
						sMSus(s);
						break;
					#endregion //Wheel Suspension
					#endregion // Attachable Blocks

					#region Ore Detector
					case "MyOreDetector":
						sOD(s);
						break;
					#endregion
					//case "MyOxygenGenerator":
					//	break;
					//case "MyOxygenTank":
					//	break;
					//#region Passage
					//case "MyPassage":
					//	sPas(s);
					//	break;
					//#endregion
					#region Piston
					case "MyPistonBase":
						sPisB(s);
						break;
					case "MyPistonTop":
						sPisT(s);
						break;
					#endregion
					#region Power Producers
					case "MyPowerProducer":
						sPP(s);
						break;
					#endregion
					#region Production Blocks
					case "MyProductionBlock":
						sProd(s);
						break;
					#endregion
					#region Programmable Block
					case "MyProgrammableBlock":
						sPB(s);
						break;
					#endregion
					#region Projector
					case "MySpaceProjector":
						sProj(s);
						break;
					#endregion
					#region Antenna
					case "MyRadioAntenna":
						sRA(s);
						break;
					#endregion
					#region Reactor
					case "MyReactor":
						sRea(s);
						break;
					#endregion
					#region Production Blocks
					case "MyRefinery":
						sRefi(s);
						break;
					#endregion
					#region Lights
					case "MyReflectorLight":
						//sRL(s);
						sLB(s);
						break;
					#endregion
					#region Remote Control
					case "MyRemoteControl":
						sRC(s);
						break;
					#endregion
					#region Sensor
					case "MySensorBlock":
						sSen(s);
						break;
					#endregion
					#region Connector
					case "MyShipConnector":
						sSConn(s);
						break;
					#endregion
					#region Ship Controller
					case "MyShipController":
						sSCtl(s);
						break;
					#endregion
					#region Ship Tools
					case "MyShipDrill":
						sSDri(s);
						break;
					case "MyShipGrinder":
						sSGri(s);
						break;
					case "MyShipToolBase":
						sSTB(s);
						break;
					case "MyShipWelder":
						sSWel(s);
						break;
					#endregion // Ship Tools
					#region Guns
					case "MySmallGatlingGun":
						sSGG(s);
						break;
					#endregion
					#region Missiles
					case "MySmallMissileLauncher":
						sSML(s);
						break;
					case "MySmallMissileLauncherReload":
						sSMLR(s);
						break;
					#endregion // Missiles
					#region Store Block
					case "MyStoreBlock":
					case "MyVendingMachine":
						sSto(s);
						break;
					#endregion


					case "MyTerminalBlock":
						sTB(s);
						break;


					#region Text
					case "MyTextPanel":
						sTP(s);
						break;
					case "MyTextSurface":
						sTS(s);
						break;
					case "MyTextSurfaceProvider":
						sTSP(s);
						break;
					#endregion // Text
					#region Thrust
					case "MyThrust":
						sThr(s);
						break;
					#endregion
					#region Comms
					case "MyUnicastListener":
						sUL(s);
						break;
					#endregion
					#region Upgrades
					case "MyUpgradableBlock":
						sUB(s);
						break;
					case "MyUpgradeModule":
						sUM(s);
						break;
					#endregion //Upgrades
					#region Guns
					case "MyUserControllableGun":
						sUCG(s);
						break;
					#endregion
					#region Warhead
					case "MyWarhead":
						sWar(s);
						break;
					#endregion
					#region Wheels
					case "MyWheel":
						sWhe(s);
						break;
					#endregion

					// SpaceEngineers.Game.ModAPI
					#region Air Vent
					case "MyAirVent": sAV(s); break;
					#endregion
					#region Artificial Mass Block
					case "MyArtificialMassBlock": sAMB(s); break;
					#endregion
					#region Buttons
					case "MyButtonPanel": sBP(s); break;
					#endregion
					#region Control Panel
					case "MyControlPanel": sCP(s); break;
					#endregion
					#region Gravity Generator
					case "MyGravityGenerator": sGrG(s); break;
					case "MyGravityGeneratorBase": sGrGB(s); break;
					case "MyGravityGeneratorSphere": sGrGS(s); break;
					#endregion
					#region Lights
					case "MyInteriorLight": sLB(s); break;
					#endregion
					#region Landing Gear
					case "MyLandingGear": sLG(s); break;
					#endregion
					#region Turrets
					case "MyLargeConveyorTurretBase": sLCTB(s); break;
					#region Guns
					case "MyLargeGatlingTurret": sLGT(s); break;
					case "MyLargeInteriorTurret": sLIT(s); break;
					#endregion
					#region Missiles
					case "MyLargeMissileTurret": sLMT(s); break;
					#endregion
					#endregion // Turrets
					#region Medical Room
					case "MyMedicalRoom": sMedR(s); break;
					#endregion
					#region Oxygen Farm
					case "MyOxygenFarm": sOxyF(s); break;
					#endregion
					#region Parachute
					case "MyParachute": sPar(s); break;
					#endregion
					#region Safe Zone
					case "MySafeZoneBlock": sSZ(s); break;
					#endregion
					#region Merge Block
					case "MyShipMergeBlock": sMer(s); break;
					#endregion
					#region Power Producers
					case "MySolarPanel": sSol(s); break;
					#endregion
					#region Sound Blocks
					case "MySoundBlock": sSnd(s); break;
					#endregion
					#region Artificial Mass Block
					case "MySpaceBall": sBal(s); break;
					#endregion
					#region Timer Block
					case "MyTimerBlock": sTim(s); break;
					#endregion
					#region Artificial Mass Block
					case "MyVirtualMass": sVMa(s); break;
					#endregion
					#region Production Blocks
					case "MySurvivalKit": sSur(s); break;
					#endregion
					#region Power Producers
					case "MyWindTurbine": sGT(s); sPP(s); break;
					case "MyHydrogenEngine": sPP(s); break;
					#endregion
					#region Text
					case "MyLCDPanelsBlock": sTSP(s); break;
					case "MyContractBlock": sTSP(s); break;
					#endregion
					#region Sound Blocks
					case "MyJukebox":
						sTSP(s); sSnd(s); break;
					#endregion
					default:
						break;
				}
			}





			#region Block/Item Definitions
			// To reverse, constructor VRage.ObjectBuilders.SerializableDefinitionId(VRage.ObjectBuilders.MyObjectBuilderType.Parse(string) typeid, string subtype)
			Var vDef(VRage.ObjectBuilders.SerializableDefinitionId x) => x.ToString();
			//{
			//	Var r = th.mkv('a');
			//	r.d["Type"] = x.TypeIdString;
			//	r.d["Subtype"] = x.SubtypeId;
			//	r.d["Full"] = x.ToString();
			//	return r;
			//}
			//{
			//	//Var r = SysVar.New(d, th);
			//	Var r = th.mkv('a');
			//	r["TypeId"] = TB(x).BlockDefinition.TypeId.ToString();
			//	r["TypeIdString"] = TB(x).BlockDefinition.TypeIdString;
			//	r["SubtypeId"] = TB(x).BlockDefinition.SubtypeId;
			//	r["SubtypeIdAttribute"] = TB(x).BlockDefinition.SubtypeIdAttribute;
			//	r["SubtypeName"] = TB(x).BlockDefinition.SubtypeName;
			//	r["TypeIdStringAttribute"] = TB(x).BlockDefinition.TypeIdStringAttribute;
			//	return r;
			//}
			VRage.ObjectBuilders.SerializableDefinitionId v2Def(Var v) => MyDefinitionId.Parse(v.str);
			//{
			//
			//	//if (false)
			//	//{
			//	//	//VRage.Game.MyDefinitionId
			//	//	VRage.Game.MyDefinitionId.Parse()
			//	//}
			//
			//	if (v.d != null && v.d.ContainsKey("Type") && v.d.ContainsKey("Subtype"))
			//		//return new VRage.ObjectBuilders.SerializableDefinitionId(VRage.ObjectBuilders.MyObjectBuilderType.Parse(v["Type"]), v["Subtype"]);
			//		return MyDefinitionId.Parse(v.str);
			//	else
			//	{
			//		var ts = v.str.Split('/');
			//		if (ts.Length == 2) return new VRage.ObjectBuilders.SerializableDefinitionId(VRage.ObjectBuilders.MyObjectBuilderType.Parse(ts[0]), ts[1]);
			//		return new VRage.ObjectBuilders.SerializableDefinitionId();
			//	}
			//}
			#endregion

			// This stuff is in Sandbox.Game.Entities
			// TODO: Base classes
			//	/ main descendant interfaces
			//	. Sandbox.Game.Entities in object browser for base types

			#region Comms
			// TODO: Broadcast sus
			IMyBroadcastListener BL(object cx) { return cx as IMyBroadcastListener; }
			IMyUnicastListener UL(object cx) { return cx as IMyUnicastListener; }
			#endregion

			// <comp name="Doors" deps="">
			#region Doors
			IMyAdvancedDoor AD(object cx) { return (cx as BCX).b as IMyAdvancedDoor; }
			IMyAirtightDoorBase ADB(object cx) { return (cx as BCX).b as IMyAirtightDoorBase; }
			IMyAirtightHangarDoor AHD(object cx) { return (cx as BCX).b as IMyAirtightHangarDoor; }
			IMyAirtightSlideDoor ASD(object cx) { return (cx as BCX).b as IMyAirtightSlideDoor; }
			void sAD(SysVar s) { sDoor(s); }
			void sADB(SysVar s) { sDoor(s); }
			void sAHD(SysVar s) { sDoor(s); }
			void sASD(SysVar s) { sDoor(s); }
			void sDoor(SysVar s)
			{
				ap(s, "Status", (object x) => Door(x).Status.ToString());
				ap(s, "OpenRatio", (object x) => Door(x).OpenRatio);

				// Obsolete, throws warning
				//ap(s, "Open", (object x) => Door(x).Open);

				am(s, "CloseDoor", (object x, List<Var> a) => { Door(x).CloseDoor(); return null; });
				am(s, "OpenDoor", (object x, List<Var> a) => { Door(x).OpenDoor(); return null; });
				am(s, "ToggleDoor", (object x, List<Var> a) => { Door(x).ToggleDoor(); return null; });
			}
			#endregion // Doors
			// </comp> Doors

			// <comp name="Production">
			#region Production Blocks
			void sAss(SysVar s)
			{
				sProd(s);
				ap(s, "CooperativeMode", (object x) => Ass(x).CooperativeMode, (object x, Var v) => Ass(x).CooperativeMode = v.tr);
				ap(s, "CurrentProgress", (object x) => Ass(x).CurrentProgress);
				// Obsolete > Mode ap(s, "DisassembleEnabled", (object x) => Ass(x).DisassembleEnabled);
				ap(s, "Mode", (object x) => Ass(x).Mode.ToString(), (object x, Var v) => Ass(x).Mode = v2e<MyAssemblerMode>(v));
				ap(s, "Repeating", (object x) => Ass(x).Repeating, (object x, Var v) => Ass(x).Repeating = v.tr);
				//ap(s, "", (object x) => Ass(x)., (object x, Var v) => Ass(x). = v);
			}
			// </comp> Production
			#endregion // Production Blocks
			#region Attachable Blocks
			IMyAttachableTopBlock ATB(object cx) { return cx as IMyAttachableTopBlock; }
			void sATB(SysVar s)
			{
				ap(s, "Base", (object x) => vBlock(ATB(x).Base));
				ap(s, "IsAttached", (object x) => ATB(x).IsAttached);
			}
			Var vATB(IMyAttachableTopBlock b)
			{
				Var r = SysVar.New(b, th);
				sATB(r.sy);
				return r;
			}
			#endregion //Attachable Blocks
			#region Power Producers
			#region Battery
			void sBB(SysVar s)
			{
				sPP(s);
				ap(s, "ChargeMode", (object x) => BB(x).ChargeMode.ToString(), (object x, Var v) => BB(x).ChargeMode = v2e<ChargeMode>(v));
				ap(s, "CurrentInput", (object x) => BB(x).CurrentInput);
				ap(s, "CurrentStoredPower", (object x) => BB(x).CurrentStoredPower);
				ap(s, "HasCapacityRemaining", (object x) => BB(x).HasCapacityRemaining);
				ap(s, "IsCharging", (object x) => BB(x).IsCharging);
				ap(s, "MaxInput", (object x) => BB(x).MaxInput);
				ap(s, "MaxStoredPower", (object x) => BB(x).MaxStoredPower);
				// Obsolete, throws warning : ap(s, "OnlyDischarge", (object x) => BB(x).OnlyDischarge, (object x, Var v) => BB(x).OnlyDischarge = v);
				// Obsolete, throws warning : ap(s, "SemiautoEnabled", (object x) => BB(x).SemiautoEnabled, (object x, Var v) => BB(x).SemiautoEnabled = v);
			}
			#endregion //Battery
			#endregion // Power Producers

			#region Beacon
			void sBea(SysVar s)
			{
				ap(s, "HudText", (object x) => Bea(x).HudText, (object x, Var v) => Bea(x).HudText = v);
				ap(s, "Radius", (object x) => Bea(x).Radius, (object x, Var v) => Bea(x).Radius = v);
			}
			#endregion
			//void sBG(SysVar s){}

			#region Comms
			void sBL(SysVar s)
			{
				sMP(s);
				//case "IsActive": return mkp(blk, 'n', () => BL(blk).IsActive);
				//case "Tag": return mkp(blk, 's', () => BL(blk).Tag);
				ap(s, "IsActive", (object x) => BL(x).IsActive);
				ap(s, "Tag", (object x) => BL(x).Tag);
			}
			Var vBL(IMyBroadcastListener bl)
			{
				Var v = SysVar.New(bl, th);
				SysVar s = v.sy;
				sBL(s);
				return v;
			}

			IMyBroadcastListener v2BL(Var v)
			{
				return BL(v.sy.cx);
			}
			#endregion // Comms

			#region Camera
			void sCam(SysVar s)
			{
				#region Raycasting
				//case "AvailableScanRange": return mkp(blk, 'n', () => Cam(blk).AvailableScanRange);
				//case "EnableRaycast": return mkp(blk, 'n', () => Cam(blk).EnableRaycast, (nv) => Cam(blk).EnableRaycast = nv.tr);
				//case "IsActive": return mkp(blk, 'n', () => Cam(blk).IsActive);
				//case "RaycastConeLimit": return mkp(blk, 'n', () => Cam(blk).RaycastConeLimit);
				//case "RaycastDistanceLimit": return mkp(blk, 'n', () => Cam(blk).RaycastDistanceLimit);
				//case "CanScan":
				//	return mkf(() =>
				//	{
				//		Var dist = th.popv().v; // double distance
				//		Var dir = th.popv().v; // Vector3D direction
				//		th.pushv((dir != null) ? Cam(blk).CanScan(dist, v2vec(dir)) : Cam(blk).CanScan(dist));
				//	});
				//case "Raycast":
				//	return mkf(() =>
				//	{
				//		Var dist = th.popv().v;
				//		Var p2 = th.popv().v;
				//		Var p3 = th.popv().v;
				//		if (p3 == null)
				//		{
				//			// Raycast(double distance, vec3 direction)
				//		}
				//		else
				//		{
				//			// Raycast(double distance, float pitch, float yaw)
				//		}
				//	});
				ap(s, "EnableRaycast", (object x) => Cam(x).EnableRaycast, (object x, Var v) => Cam(x).EnableRaycast = v);
				ap(s, "RaycastConeLimit", (object x) => Cam(x).RaycastConeLimit);
				ap(s, "RaycastDistanceLimit", (object x) => Cam(x).RaycastDistanceLimit);
				ap(s, "AvailableScanRange", (object x) => Cam(x).AvailableScanRange);
				ap(s, "IsActive", (object x) => Cam(x).IsActive);

				#region Geometry !nodep
				am(s, "CanScan", (object x, List<Var> a) =>
				{
					var c = Cam(x);
					if (a.Count == 1 && a[0].ty == 'n') return c.CanScan(a[0]);
					if (a.Count == 1 && a[0].ty == 'a') return c.CanScan(v2vec(a[0]));
					if (a.Count >= 2) return c.CanScan(a[0], v2vec(a[1]));
					return false;
				});
				#region Entities !nodep
				am(s, "Raycast", (object x, List<Var> a) =>
				{
					var c = Cam(x);
					//var d = new MyDetectedEntityInfo();
					if (a.Count >= 3 && a[0].ty == 'n' && a[1].ty == 'n' && a[2].ty == 'n')
						return vDEI(c.Raycast(a[0], (float)a[1], (float)a[2]));
					if (a.Count >= 2 && a[0].ty == 'n' && a[1].ty == 'a')
						return vDEI(c.Raycast(a[0], v2vec(a[1])));
					if (a.Count >= 1 && a[0].ty == 'a')
						return vDEI(c.Raycast(v2vec(a[0])));
					return null;
				});
				#endregion // Entities
				#endregion // Geometry
				am(s, "TimeUntilScan", (object x, List<Var> a) => Cam(x).TimeUntilScan(a[0]));
				#endregion // Raycasting

			}
			#endregion // Camera

			#region Inventory
			void sCC(SysVar s) { } // Base types handle cargo container inventories
			#endregion
			#region Cockpit
			void sCoc(SysVar s)
			{
				// TODO: Base probably ship controller
				sSCtl(s);
				#region Text !nodep
				sTS(s);
				#endregion
				ap(s, "OxygenCapacity", (object x) => Coc(x).OxygenCapacity);
				ap(s, "OxygenFilledRatio", (object x) => Coc(x).OxygenFilledRatio);
			}
			#endregion
			#region Collector
			void sCol(SysVar s)
			{
				ap(s, "UseConveyorSystem", (object x) => Col(x).UseConveyorSystem);
			}
			#endregion
			#region Conveyor
			void sConv(SysVar s) { }
			#region Sorter
			void sCS(SysVar s)
			{
				ap(s, "DrainAll", (object x) => CS(x).DrainAll, (object x, Var v) => CS(x).DrainAll = v);
				ap(s, "Mode", (object x) => CS(x).Mode.ToString());

				#region Inventory Items !nodep
				am(s, "AddItem", (object x, List<Var> a) => { CS(x).AddItem(v2InvItemFilter(a[0])); return null; });
				am(s, "GetFilterList", (object x, List<Var> a) =>
				{
					//IMyCargoContainer cc;
					//MyInventoryItem im; im.Type.TypeId;
					//MyInventoryItem item; item.Type.TypeId + " - " + item.Type.SubtypeId;
					//new MyInventoryItem(item.Type.TypeId, item.ItemId, item.Amount)
					//new MyItemType()
					var l = new List<MyInventoryItemFilter>();
					Var r = th.mkv('a');
					CS(x).GetFilterList(l);
					foreach (var f in l)
					{
						r.a.Add(vInvItemFilter(f));
					}
					return r;
				});
				// Some types involving block definitions there's just no way to encapsulate or access them
				//am(s, "IsAllowed", (object x, List<Var> a) => { CS(x).IsAllowed(new VRage.Game.MyDefinitionId(; return null; });
				am(s, "RemoveItem", (object x, List<Var> a) => { CS(x).RemoveItem(v2InvItemFilter(a[0])); return null; });
				am(s, "SetFilter", (object x, List<Var> a) =>
				{
					var l = new List<MyInventoryItemFilter>();
					if (a.Count != 2 || a[0].ty != 's' || a[1].ty != 'a' || a[0].a == null) return null;
					for (int i = 0; i < a[0].a.Count; i++)
					{
						l.Add(v2InvItemFilter(a[i]));
					}

					CS(x).SetFilter(v2e<MyConveyorSorterMode>(a[0]), l);
					return null;
				});
				#endregion // Inventory Items
				//am(s, "", (object x, List<Var> a) => { CS(x).; return null; });

			}
			#endregion // Sorter
			#endregion // Conveyor

			#region Conveyor
			// Conveyor Tube
			void sCT(SysVar s) { }
			#endregion
			#region Cryo Chamber
			void sCry(SysVar s)
			{
				sCoc(s);
				sSCtl(s);
				#region Text !nodep
				sTSP(s);
				#endregion
			}
			#endregion
			#region Decoy
			//void sDec(SysVar s) {}
			#endregion
			#region Piston
			// Extended Piston Base
			void sEPB(SysVar s)
			{
				sMCB(s);
				sPisB(s);
			}
			#endregion

			// Functional Block
			void sFB(SysVar s)
			{
				ap(s, "Enabled", (object x) => FB(x).Enabled, (object x, Var v) => FB(x).Enabled = v);
				//am(s, "RequestEnable", (object x, List<Var> a) => { FB(x).RequestEnable(a[0]); return null;});
			}
			#region Gas Generator
			// Gas Generator
			void sGG(SysVar s)
			{
				ap(s, "AutoRefill", (object x) => GG(x).AutoRefill, (object x, Var v) => GG(x).AutoRefill = v);
				ap(s, "UseConveyorSystem", (object x) => GG(x).UseConveyorSystem, (object x, Var v) => GG(x).UseConveyorSystem = v);
			}
			#endregion
			#region Gas Tank
			void sGT(SysVar s)
			{
				ap(s, "AutoRefillBottles", (object x) => GT(x).AutoRefillBottles, (object x, Var v) => GT(x).AutoRefillBottles = v);
				ap(s, "Capacity", (object x) => GT(x).Capacity);
				ap(s, "FilledRatio", (object x) => GT(x).FilledRatio);
				ap(s, "Stockpile", (object x) => GT(x).Stockpile, (object x, Var v) => GT(x).Stockpile = v);

				am(s, "RefillBottles", (object x, List<Var> a) => { GT(x).RefillBottles(); return null; });
			}
			#endregion

			//IMyGridTerminalSystem GTS(object cx) { return cx as IMyGridTerminalSystem; }
			//IMyGridProgramRuntimeInfo GPRI(object cx) { return cx as IMyGridProgramRuntimeInfo; }
			//void sGPRI(SysVar s)
			//{
			//	ap(s, "CurrentCallChainDepth", (object x) => GPRI(x).CurrentCallChainDepth);
			//	ap(s, "CurrentInstructionCount", (object x) => GPRI(x).CurrentInstructionCount);
			//	ap(s, "LastRunTimeMs", (object x) => GPRI(x).LastRunTimeMs);
			//	ap(s, "MaxCallChainDepth", (object x) => GPRI(x).MaxCallChainDepth);
			//	ap(s, "MaxInstructionCount", (object x) => GPRI(x).MaxInstructionCount);
			//	ap(s, "TimeSinceLastRun", (object x) => GPRI(x).TimeSinceLastRun.TotalSeconds);
			//	ap(s, "", (object x) => GPRI(x).UpdateFrequency.ToString(), (object x, Var v) => GPRI(x).UpdateFrequency = v2e<UpdateFrequency>(v));
			//}
			// The system's Resolve() function takes care of GridTerminalSystem, it's just a way to find blocks
			//void sGTS(SysVar s) { }

			#region Gyro
			void sGyr(SysVar s)
			{
				ap(s, "GyroOverride", (object x) => Gyr(x).GyroOverride, (object x, Var v) => Gyr(x).GyroOverride = v);
				ap(s, "GyroPower", (object x) => Gyr(x).GyroPower, (object x, Var v) => Gyr(x).GyroPower = v);
				ap(s, "Pitch", (object x) => Gyr(x).Pitch, (object x, Var v) => Gyr(x).Pitch = v);
				ap(s, "Roll", (object x) => Gyr(x).Roll, (object x, Var v) => Gyr(x).Roll = v);
				ap(s, "Yaw", (object x) => Gyr(x).Yaw, (object x, Var v) => Gyr(x).Yaw = v);
			}
			#endregion
			#region Comms
			void sIGCS(SysVar s)
			{
				ap(s, "Me", (object x) => IGCS(x).Me);
				ap(s, "UnicastListener", (object x) => vUL(IGCS(x).UnicastListener));

				am(s, "DisableBroadcastListener", (object x, List<Var> a) => { IGCS(x).DisableBroadcastListener(v2BL(a[0])); return null; });
				am(s, "GetBroadcastListeners", (object x, List<Var> a) =>
				{
					var l = new List<IMyBroadcastListener>();
					IGCS(x).GetBroadcastListeners(l);
					Var r = th.mkv('a');
					foreach (var b in l)
					{
						r.a.Add(vBL(b));
					}
					return r;
				});
				am(s, "IsEndpointReachable", (object x, List<Var> a) => IGCS(x).IsEndpointReachable((long)a[0], v2e<TransmissionDistance>(a[1])));
				am(s, "RegisterBroadcastListener", (object x, List<Var> a) => vBL(IGCS(x).RegisterBroadcastListener(a[0])));
				am(s, "SendBroadcastMessage", (object x, List<Var> a) =>
				{
					//print(console, $"sbm {a.Count} args\n");
					if (x == null) print(console, "sbm x null!");
					//print(console, $"IGC id {IGCS(x).Me}\n");
					if (a.Count > 2) IGCS(x).SendBroadcastMessage<string>(a[0], a[1], v2e<TransmissionDistance>(a[2]));
					else IGCS(x).SendBroadcastMessage<string>(a[0], a[1]);
					return null; 
				});
				am(s, "SendUnicastMessage", (object x, List<Var> a) => IGCS(x).SendUnicastMessage<string>((long)a[0], a[1], a[2]));
			}
			#endregion
			#region Jump Drive
			void sJD(SysVar s)
			{
				ap(s, "CurrentStoredPower", (object x) => JD(x).CurrentStoredPower);
				ap(s, "MaxStoredPower", (object x) => JD(x).MaxStoredPower);
				ap(s, "Status", (object x) => JD(x).Status.ToString());
			}
			#endregion
			#region Turrets
			void sLTB(SysVar s)
			{
				ap(s, "AIEnabled", (object x) => LTB(x).AIEnabled);
				ap(s, "Azimuth", (object x) => LTB(x).Azimuth, (object x, Var v) => LTB(x).Azimuth = v);
				ap(s, "CanControl", (object x) => LTB(x).CanControl);
				ap(s, "Elevation", (object x) => LTB(x).Elevation, (object x, Var v) => LTB(x).Elevation = v);
				ap(s, "EnableIdleRotation", (object x) => LTB(x).EnableIdleRotation, (object x, Var v) => LTB(x).EnableIdleRotation = v);
				ap(s, "HasTarget", (object x) => LTB(x).HasTarget);
				ap(s, "IsAimed", (object x) => LTB(x).IsAimed);
				ap(s, "IsUnderControl", (object x) => LTB(x).IsUnderControl);
				ap(s, "Range", (object x) => LTB(x).Range);

				#region Entities !nodep
				am(s, "GetTargetedEntity", (object x, List<Var> a) => vDEI(LTB(x).GetTargetedEntity()));
				#endregion
				am(s, "ResetTargetingToDefault", (object x, List<Var> a) => { LTB(x).ResetTargetingToDefault(); return null; });
				#region Geometry !nodep
				am(s, "SetTarget", (object x, List<Var> a) => { LTB(x).SetTarget(v2vec(a[0])); return null; });
				am(s, "TrackTarget", (object x, List<Var> a) => { LTB(x).TrackTarget(v2vec(a[0]), v2vec(a[1])); return null; });
				#endregion
				am(s, "SyncAzimuth", (object x, List<Var> a) => { LTB(x).SyncAzimuth(); return null; });
				am(s, "SyncElevation", (object x, List<Var> a) => { LTB(x).SyncElevation(); return null; });
				am(s, "SyncEnableIdleRotation", (object x, List<Var> a) => { LTB(x).SyncEnableIdleRotation(); return null; });

			}
			#endregion
			#region Antenna
			void sLA(SysVar s)
			{
				// Obsolete -> Status ap(s, "IsOutsideLimits", (object x) => LA(x).IsOutsideLimits);
				ap(s, "IsPermanent", (object x) => LA(x).IsPermanent, (object x, Var v) => LA(x).IsPermanent = v);
				ap(s, "Range", (object x) => LA(x).Range, (object x, Var v) => LA(x).Range = v);
				ap(s, "RequireLoS", (object x) => LA(x).RequireLoS);
				ap(s, "Status", (object x) => LA(x).Status.ToString());
				#region Geometry !nodep
				ap(s, "TargetCoords", (object x) => vVec(LA(x).TargetCoords));
				am(s, "SetTargetCoords", (object x, List<Var> a) => { LA(x).SetTargetCoords(a[0]); return null; });
				#endregion

				am(s, "Connect", (object x, List<Var> a) => { LA(x).Connect(); return null; });
			}
			#endregion
			#region Lights
			void sLB(SysVar s)
			{
				// TODO: make an implicit float operator so i don't have to do all these casts
				ap(s, "BlinkIntervalSeconds", (object x) => LB(x).BlinkIntervalSeconds, (object x, Var v) => LB(x).BlinkIntervalSeconds = v);
				ap(s, "BlinkLength", (object x) => LB(x).BlinkLength, (object x, Var v) => LB(x).BlinkLength = v);
				ap(s, "BlinkOffset", (object x) => LB(x).BlinkOffset, (object x, Var v) => LB(x).BlinkOffset = v);
				ap(s, "Color", (object x) => LB(x).Color.PackedValue, (object x, Var v) => LB(x).Color = new Color((uint)v));
				ap(s, "Falloff", (object x) => LB(x).Falloff, (object x, Var v) => LB(x).Falloff = v);
				ap(s, "Intensity", (object x) => LB(x).Intensity, (object x, Var v) => LB(x).Intensity = v);
				ap(s, "Radius", (object x) => LB(x).Radius, (object x, Var v) => LB(x).Radius = v);
				//ap(s, "ReflectorRadius", (object x) => LB(x).ReflectorRadius);
			}
			#endregion
			#region Attachable Blocks
			void sMCB(SysVar s)
			{
				ap(s, "IsAttached", (object x) => MCB(x).IsAttached);
				// Obsolete, throws warning : ap(s, "IsLocked", (object x) => MCB(x).IsLocked);
				ap(s, "PendingAttachment", (object x) => MCB(x).PendingAttachment);
				// Obsolete, throws warning : ap(s, "SafetyLock", (object x) => MCB(x).SafetyLock, (object x, Var v) => MCB(x).SafetyLock = v);
				// Obsolete, throws warning : ap(s, "SafetyLockSpeed", (object x) => MCB(x).SafetyLockSpeed, (object x, Var v) => MCB(x).SafetyLockSpeed = v);
				ap(s, "Top", (object x) => vATB(MCB(x).Top));
				#region Cube Grid !nodep
				ap(s, "TopGrid", (object x) => vCubeGrid(MCB(x).TopGrid));
				#endregion

				am(s, "Attach", (object x, List<Var> a) => { MCB(x).Attach(); return null; });
				am(s, "Detach", (object x, List<Var> a) => { MCB(x).Detach(); return null; });
			}
			#endregion

			#region Comms
			IMyMessageProvider MP(object cx) { return cx as IMyMessageProvider; }
			Var vIGCMsg(MyIGCMessage m)
			{
				Var r = th.mkv('a');
				r["Tag"] = m.Tag;
				r["Source"] = m.Source;
				r["Data"] = m.As<string>();
				return r;
				//print(console, m.Tag); // + ":" + m.Data.ToString());
				//print(console, ", ");
				//print(console, m.Data.ToString());
				//print(console, ",");
				//print(console, m.As<string>());
				//print(console, "\n");
				//string str = m.As<string>();
				//print(console, "got str\n");
				//Var r = str;
				//print(console, "got Var r\n");
				//return r;
			}
			void sMP(SysVar s)
			{
				ap(s, "HasPendingMessage", (object x) =>
				{
					// TODO: Condense to () => .
					//print(console, $"in HasPendingMessage, x {x != null}");
					return MP(x).HasPendingMessage;
				});
				ap(s, "MaxWaitingMessages", (object x) => MP(x).MaxWaitingMessages);

				am(s, "AcceptMessage", (object x, List<Var> a) => vIGCMsg(MP(x).AcceptMessage()));

				// TODO: SetMessageCallback seems great for a watch, but maybe one on .HasPendingMessage would work.
				// Would need significant glue to make work, and I'm pushing the limit on code size already.
				//am(s, "SetMessageCallback", (object x, List<Var> a) => { MP(x).SetMessageCallback(a[0]); return null;});
				//am(s, "DisableMessageCallback", (object x, List<Var> a) => { MP(x).DisableMessageCallback(); return null;});

			}
			#endregion // Comms

			#region Attachable Blocks
			#region Rotors
			void sMAR(SysVar s) { }
			void sMAS(SysVar s) // This the actual type of the "Advanced Rotor" block in the UI
			{
				sMSta(s);
			}
			void sMB(SysVar s) { sMCB(s); }
			void sMR(SysVar s) { }
			void sMSta(SysVar s)
			{
				sMB(s);
				sMCB(s);
				ap(s, "Angle", (object x) => MSta(x).Angle);
				ap(s, "BrakingTorque", (object x) => MSta(x).BrakingTorque, (object x, Var v) => MSta(x).BrakingTorque = v);
				ap(s, "Displacement", (object x) => MSta(x).Displacement, (object x, Var v) => MSta(x).Displacement = v);
				ap(s, "LowerLimitDeg", (object x) => MSta(x).LowerLimitDeg, (object x, Var v) => MSta(x).LowerLimitDeg = v);
				ap(s, "LowerLimitRad", (object x) => MSta(x).LowerLimitRad, (object x, Var v) => MSta(x).LowerLimitRad = v);
				ap(s, "RotorLock", (object x) => MSta(x).RotorLock, (object x, Var v) => MSta(x).RotorLock = v);
				ap(s, "TargetVelocityRad", (object x) => MSta(x).TargetVelocityRad, (object x, Var v) => MSta(x).TargetVelocityRad = v);
				ap(s, "Torque", (object x) => MSta(x).Torque, (object x, Var v) => MSta(x).Torque = v);
				ap(s, "UpperLimitDeg", (object x) => MSta(x).UpperLimitDeg, (object x, Var v) => MSta(x).UpperLimitDeg = v);
				ap(s, "UpperLimitRad", (object x) => MSta(x).UpperLimitRad, (object x, Var v) => MSta(x).UpperLimitRad = v);
			}
			#endregion //Rotors
			#region Wheel Suspension
			void sMSus(SysVar s)
			{
				sMB(s);
				ap(s, "AirShockEnabled", (object x) => MSus(x).AirShockEnabled, (object x, Var v) => MSus(x).AirShockEnabled = v);
				ap(s, "Brake", (object x) => MSus(x).Brake, (object x, Var v) => MSus(x).Brake = v);
				ap(s, "Damping", (object x) => MSus(x).Damping);
				ap(s, "Friction", (object x) => MSus(x).Friction, (object x, Var v) => MSus(x).Friction = v);
				ap(s, "Height", (object x) => MSus(x).Height, (object x, Var v) => MSus(x).Height = v);
				ap(s, "InvertPropulsion", (object x) => MSus(x).InvertPropulsion, (object x, Var v) => MSus(x).InvertPropulsion = v);
				ap(s, "InvertSteer", (object x) => MSus(x).InvertSteer, (object x, Var v) => MSus(x).InvertSteer = v);
				ap(s, "MaxSteerAngle", (object x) => MSus(x).MaxSteerAngle, (object x, Var v) => MSus(x).MaxSteerAngle = v);
				ap(s, "Power", (object x) => MSus(x).Power, (object x, Var v) => MSus(x).Power = v);
				ap(s, "Propulsion", (object x) => MSus(x).Propulsion, (object x, Var v) => MSus(x).Propulsion = v);
				ap(s, "SteerAngle", (object x) => MSus(x).SteerAngle);
				ap(s, "Steering", (object x) => MSus(x).Steering, (object x, Var v) => MSus(x).Steering = v);
				ap(s, "SteerReturnSpeed", (object x) => MSus(x).SteerReturnSpeed);
				ap(s, "SteerSpeed", (object x) => MSus(x).SteerSpeed);
				ap(s, "Strength", (object x) => MSus(x).Strength, (object x, Var v) => MSus(x).Strength = v);
				ap(s, "SuspensionTravel", (object x) => MSus(x).SuspensionTravel);
			}
			#endregion //Wheel Suspension
			#endregion //Attachable Blocks

			#region Ore Detector
			void sOD(SysVar s)
			{
				ap(s, "BroadcastUsingAntennas", (object x) => OD(x).BroadcastUsingAntennas, (object x, Var v) => OD(x).BroadcastUsingAntennas = v);
				ap(s, "Range", (object x) => OD(x).Range);
			}
			#endregion

			#region Oxygen Generator
			// TODO: Declare Oxygen Generator
			//void sOG(SysVar s) { }
			#endregion
			//#region Oxygen Tank
			//void sOT(SysVar s)
			//{
			//	am(s, "", (object x, List<Var> a) => (x as IMyOxygenTank).GetOxygenLevel());
			//}
			//#endregion
			//#region Passage
			//void sPas(SysVar s) { }
			//#endregion

			#region Attachable Blocks
			#region Piston
			void sPisB(SysVar s)
			{
				ap(s, "CurrentPosition", (object x) => PisB(x).CurrentPosition);
				ap(s, "HighestPosition", (object x) => PisB(x).HighestPosition);
				ap(s, "LowestPosition", (object x) => PisB(x).LowestPosition);
				ap(s, "MaxLimit", (object x) => PisB(x).MaxLimit, (object x, Var v) => PisB(x).MaxLimit = v);
				ap(s, "MaxVelocity", (object x) => PisB(x).MaxVelocity);
				ap(s, "MinLimit", (object x) => PisB(x).MinLimit, (object x, Var v) => PisB(x).MinLimit = v);
				ap(s, "Status", (object x) => PisB(x).Status.ToString());
				ap(s, "Velocity", (object x) => PisB(x).Velocity, (object x, Var v) => PisB(x).Velocity = v);

				am(s, "Extend", (object x, List<Var> a) => { PisB(x).Extend(); return null; });
				am(s, "Retract", (object x, List<Var> a) => { PisB(x).Retract(); return null; });
				am(s, "Reverse", (object x, List<Var> a) => { PisB(x).Reverse(); return null; });
			}
			void sPisT(SysVar s) { }
			#endregion //Piston
			#endregion //Attachable Blocks
			#region Power Producers
			void sPP(SysVar s)
			{
				ap(s, "CurrentOutput", (object x) => PP(x).CurrentOutput);
				ap(s, "MaxOutput", (object x) => PP(x).MaxOutput);
			}
			#endregion

			#region Inventory Items
			MyDefinitionId v2Df(Var v)
			{
				return MyDefinitionId.Parse(v.str);
			}
			#endregion


			#region Production Blocks
			void sProd(SysVar s)
			{
				ap(s, "InputInventory", (object x) => vInv(Prod(x).InputInventory));
				ap(s, "IsProducing", (object x) => Prod(x).IsProducing);
				ap(s, "IsQueueEmpty", (object x) => Prod(x).IsQueueEmpty);
				ap(s, "NextItemId", (object x) => Prod(x).NextItemId);
				ap(s, "OutputInventory", (object x) => vInv(Prod(x).OutputInventory));
				ap(s, "UseConveyorSystem", (object x) => Prod(x).UseConveyorSystem, (object x, Var v) => Prod(x).UseConveyorSystem = v);

				am(s, "ClearQueue", (object x, List<Var> a) => { Prod(x).ClearQueue(); return null; });
				am(s, "MoveQueueItemRequest", (object x, List<Var> a) => { Prod(x).MoveQueueItemRequest((uint)a[0], a[1]); return null; });
				am(s, "RemoveQueueItem", (object x, List<Var> a) => { Prod(x).RemoveQueueItem(a[0], a[1].num); return null; });
				//am(s, "", (object x, List<Var> a) => { Prod(x).;return null; });


				#region Inventory Items !nodep
				//Prod(s).AddQueueItem(MyDefinitionId.Parse("MyObjectBuilder_Ore/Iron"))
				am(s, "AddQueueItem", (object x, List<Var> a) => { Prod(x).AddQueueItem(v2Df(a[0]), a[1].num); return null; });
				am(s, "CanUseBlueprint", (object x, List<Var> a) => Prod(x).CanUseBlueprint(v2Df(a[0])));
				am(s, "InsertQueueItem", (object x, List<Var> a) => { Prod(x).InsertQueueItem(a[0], v2Df(a[1]), a[2].num); return null; });
				am(s, "GetQueue", (object x, List<Var> a) =>
				{
					Var r = th.mkv('a');
					var L = new List<MyProductionItem>();
					Prod(x).GetQueue(L);
					int i = 0;
					foreach (var m in L)
					{
						var q = th.mkv('a');
						q["ItemId"] = m.ItemId;
						q["BlueprintId"] = m.BlueprintId.ToString(); //"MyObjectBuilder_Ore/Iron"
						q["Amount"] = (double)m.Amount.RawValue / 1000000;
						r.a[i++] = q;
					}
					return r;
				});
				#endregion //Inventory Items

				//am(s, "", (object x, List<Var> a) => { Prod(x).; return null;});
			}
			#endregion // Production Blocks
			#region Programmable Block
			void sPB(SysVar s)
			{
				#region Text !nodep
				sTSP(s);
				#endregion
				
				ap(s, "IsRunning", (object x) => PB(x).IsRunning);
				ap(s, "TerminalRunArgument", (object x) => PB(x).TerminalRunArgument);

				am(s, "TryRun", (object x, List<Var> a) => PB(x).TryRun(a[0]));
			}
			#endregion
			#region Projector
			void sProj(SysVar s)
			{
				#region Text !nodep
				sTSP(s);
				#endregion
				ap(s, "BuildableBlocksCount", (object x) => Proj(x).BuildableBlocksCount);
				ap(s, "IsProjecting", (object x) => Proj(x).IsProjecting);

				#region Geometry !nodep
				ap(s, "ProjectionOffset", (object x) => vVec(Proj(x).ProjectionOffset), (object x, Var v) => Proj(x).ProjectionOffset = (Vector3I)v2vec(v));
				ap(s, "ProjectionRotation", (object x) => vVec(Proj(x).ProjectionRotation), (object x, Var v) => Proj(x).ProjectionRotation = (Vector3I)v2vec(v));
				#endregion //Geometry

				ap(s, "RemainingArmorBlocks", (object x) => Proj(x).RemainingArmorBlocks);
				ap(s, "RemainingBlocks", (object x) => Proj(x).RemainingBlocks);
				// TODO: Need that definition stuff
				//ap(s, "RemainingBlocksPerType", (object x) => Proj(x).RemainingBlocksPerType, (object x, Var v) => Proj(x). = v);
				ap(s, "ShowOnlyBuildable", (object x) => Proj(x).ShowOnlyBuildable, (object x, Var v) => Proj(x).ShowOnlyBuildable = v);
				ap(s, "TotalBlocks", (object x) => Proj(x).TotalBlocks);

				am(s, "UpdateOffsetAndRotation", (object x, List<Var> a) => { Proj(x).UpdateOffsetAndRotation(); return null; });
			}
			#endregion
			#region Antenna
			void sRA(SysVar s)
			{
				ap(s, "EnableBroadcasting", (object x) => RA(x).EnableBroadcasting, (object x, Var v) => RA(x).EnableBroadcasting = v);
				ap(s, "HudText", (object x) => RA(x).HudText, (object x, Var v) => RA(x).HudText = v);
				ap(s, "IsBroadcasting", (object x) => RA(x).IsBroadcasting);
				ap(s, "Radius", (object x) => RA(x).Radius, (object x, Var v) => RA(x).Radius = v);
				ap(s, "ShowShipName", (object x) => RA(x).ShowShipName, (object x, Var v) => RA(x).ShowShipName = v);
			}
			#endregion

			#region Power Producers
			#region Reactor
			void sRea(SysVar s)
			{
				sPP(s);
				ap(s, "UseConveyorSystem", (object x) => Rea(x).UseConveyorSystem, (object x, Var v) => Rea(x).UseConveyorSystem = v);
			}
			#endregion // Reactor
			#endregion // Power Producers

			#region Production Blocks
			void sRefi(SysVar s)
			{
				sProd(s);
			}
			#endregion

			#region Lights
			//void sRL(SysVar s) { sLB(s); }
			#endregion


			#region Waypoints
			Var vWayInf(MyWaypointInfo i)
			{
				Var r = th.mkv('a');
				Var n = th.mkv('s');
				n = i.Name;
				r["Name"] = n;
				r["Coords"] = vVec(i.Coords);
				return r;
			}
			MyWaypointInfo v2WayInf(Var v) => new MyWaypointInfo(v["Name"], v2vec(v["Coords"]));
			#endregion // Waypoints
			#region Remote Control
			void sRC(SysVar s)
			{
				sSCtl(s);
				ap(s, "Direction", (object x) => RC(x).Direction.ToString(), (object x, Var v) => RC(x).Direction = v2e<Base6Directions.Direction>(v));
				ap(s, "FlightMode", (object x) => RC(x).FlightMode.ToString(), (object x, Var v) => RC(x).FlightMode = v2e<FlightMode>(v));
				ap(s, "IsAutoPilotEnabled", (object x) => RC(x).IsAutoPilotEnabled);
				ap(s, "SpeedLimit", (object x) => RC(x).SpeedLimit, (object x, Var v) => RC(x).SpeedLimit = v);
				ap(s, "WaitForFreeWay", (object x) => RC(x).WaitForFreeWay, (object x, Var v) => RC(x).WaitForFreeWay = v);

				#region Waypoints
				ap(s, "CurrentWaypoint", (object x) => vWayInf(RC(x).CurrentWaypoint));
				am(s, "AddWaypoint", (object x, List<Var> a) =>
				{
					if (a.Count == 1) RC(x).AddWaypoint(v2WayInf(a[0]));
					else if (a.Count == 2) RC(x).AddWaypoint(v2vec(a[0]), a[1]);
					return null;
				});
				am(s, "ClearWaypoints", (object x, List<Var> a) => { RC(x).ClearWaypoints(); return null; });
				am(s, "GetWaypointInfo", (object x, List<Var> a) =>
				{
					Var r = th.mkv('a');
					var l = new List<MyWaypointInfo>();
					RC(x).GetWaypointInfo(l);
					foreach (var w in l)
					{
						r.a.Add(vWayInf(w));
					}
					return r;
				});
				#endregion // Waypoints
				#region Geometry !nodep
				// Only works if remote control is owned by an NPC
				am(s, "GetNearestPlayer", (object x, List<Var> a) =>
				{
					var vc = new Vector3D();
					if (RC(x).GetNearestPlayer(out vc)) return vVec(vc);
					return null;
				});
				#endregion //Geometry
				am(s, "SetAutoPilotEnabled", (object x, List<Var> a) => { RC(x).SetAutoPilotEnabled(a[0]); return null; });
				am(s, "SetCollisionAvoidance", (object x, List<Var> a) => { RC(x).SetCollisionAvoidance(a[0]); return null; });
				am(s, "SetDockingMode", (object x, List<Var> a) => { RC(x).SetDockingMode(a[0]); return null; });
			}
			#endregion //Remote Control
			#region Sensor
			void sSen(SysVar s)
			{
				// <comp name="Entities">
				#region Entities !nodep
				am(s, "DetectedEntities", (object x, List<Var> a) =>
				{
					Var r = th.mkv('a');
					var l = new List<MyDetectedEntityInfo>();
					Sen(x).DetectedEntities(l);
					foreach (var e in l)
					{
						r.a.Add(vDEI(e));
					}
					return r;
				});
				ap(s, "LastDetectedEntity", (object x) => vDEI(Sen(x).LastDetectedEntity));
				#endregion //Entities
				// </comp> Entities

				ap(s, "BackExtend", (object x) => Sen(x).BackExtend, (object x, Var v) => Sen(x).BackExtend = v);
				ap(s, "BottomExtend", (object x) => Sen(x).BottomExtend, (object x, Var v) => Sen(x).BottomExtend = v);
				ap(s, "DetectAsteroids", (object x) => Sen(x).DetectAsteroids, (object x, Var v) => Sen(x).DetectAsteroids = v);
				ap(s, "DetectEnemy", (object x) => Sen(x).DetectEnemy, (object x, Var v) => Sen(x).DetectEnemy = v);
				ap(s, "DetectFloatingObjects", (object x) => Sen(x).DetectFloatingObjects, (object x, Var v) => Sen(x).DetectFloatingObjects = v);
				ap(s, "DetectFriendly", (object x) => Sen(x).DetectFriendly, (object x, Var v) => Sen(x).DetectFriendly = v);
				ap(s, "DetectLargeShips", (object x) => Sen(x).DetectLargeShips, (object x, Var v) => Sen(x).DetectLargeShips = v);
				ap(s, "DetectNeutral", (object x) => Sen(x).DetectNeutral, (object x, Var v) => Sen(x).DetectNeutral = v);
				ap(s, "DetectOwner", (object x) => Sen(x).DetectOwner, (object x, Var v) => Sen(x).DetectOwner = v);
				ap(s, "DetectPlayers", (object x) => Sen(x).DetectPlayers, (object x, Var v) => Sen(x).DetectPlayers = v);
				ap(s, "DetectSmallShips", (object x) => Sen(x).DetectSmallShips, (object x, Var v) => Sen(x).DetectSmallShips = v);
				ap(s, "DetectStations", (object x) => Sen(x).DetectStations, (object x, Var v) => Sen(x).DetectStations = v);
				ap(s, "DetectSubgrids", (object x) => Sen(x).DetectSubgrids, (object x, Var v) => Sen(x).DetectSubgrids = v);
				ap(s, "FrontExtend", (object x) => Sen(x).FrontExtend, (object x, Var v) => Sen(x).FrontExtend = v);
				ap(s, "IsActive", (object x) => Sen(x).IsActive);
				ap(s, "LeftExtend", (object x) => Sen(x).LeftExtend, (object x, Var v) => Sen(x).LeftExtend = v);
				ap(s, "MaxRange", (object x) => Sen(x).MaxRange);
				ap(s, "PlayProximitySound", (object x) => Sen(x).PlayProximitySound, (object x, Var v) => Sen(x).PlayProximitySound = v);
				ap(s, "RightExtend", (object x) => Sen(x).RightExtend, (object x, Var v) => Sen(x).RightExtend = v);
				ap(s, "TopExtend", (object x) => Sen(x).TopExtend, (object x, Var v) => Sen(x).TopExtend = v);
			}
			#endregion
			#region Connector
			void sSConn(SysVar s)
			{
				ap(s, "CollectAll", (object x) => SConn(x).CollectAll, (object x, Var v) => SConn(x).CollectAll = v);
				// Obsolete > Status ap(s, "IsConnected", (object x) => SConn(x).IsConnected);
				// Osbsolete > Status ap(s, "IsLocked", (object x) => SConn(x).IsLocked);
				ap(s, "OtherConnector", (object x) => vBlock(SConn(x).OtherConnector));
				ap(s, "PullStrength", (object x) => SConn(x).PullStrength, (object x, Var v) => SConn(x).PullStrength = v);
				ap(s, "Status", (object x) => SConn(x).Status.ToString());
				ap(s, "ThrowOut", (object x) => SConn(x).ThrowOut, (object x, Var v) => SConn(x).ThrowOut = v);

				am(s, "Connect", (object x, List<Var> a) => { SConn(x).Connect(); return null; });
				am(s, "Disconnect", (object x, List<Var> a) => { SConn(x).Disconnect(); return null; });
				am(s, "ToggleConnect", (object x, List<Var> a) => { SConn(x).ToggleConnect(); return null; });
			}
			#endregion //Connector

			#region Geometry
			Var vVec2f(Vector2 vc)
			{
				//m_prg.Echo("vVec2f() start");
				Var r = th.mkv('a');
				r["X"] = vc.X;
				r["Y"] = vc.Y;
				//m_prg.Echo("vVec2f() end");
				return r;
			}
			#endregion // Geometry

			#region Ship Controller
			Var vShipMass(MyShipMass m)
			{
				Var r = th.mkv('a');
				r.d["BaseMass"] = m.BaseMass;
				r.d["PhysicalMass"] = m.PhysicalMass;
				r.d["TotalMass"] = m.TotalMass;
				return r;
			}
			#region Geometry !nodep
			Var vShipVel(MyShipVelocities ve)
			{
				Var r = th.mkv('a');
				r["AngularVelocity"] = vVec(ve.AngularVelocity);
				r["LinearVelocity"] = vVec(ve.LinearVelocity);
				return r;
			}
			#endregion //Geometry
			void sSCtl(SysVar s)
			{
				#region Geometry !nodep
				ap(s, "CenterOfMass", (object x) => vVec(SCtl(x).CenterOfMass));
				ap(s, "MoveIndicator", (object x) => vVec(SCtl(x).MoveIndicator));
				ap(s, "RotationIndicator", (object x) => vVec2f(SCtl(x).RotationIndicator));
				am(s, "GetArtificialGravity", (object x, List<Var> a) => vVec(SCtl(x).GetArtificialGravity()));
				am(s, "GetNaturalGravity", (object x, List<Var> a) => vVec(SCtl(x).GetNaturalGravity()));
				am(s, "GetShipVelocities", (object x, List<Var> a) => vShipVel(SCtl(x).GetShipVelocities()));
				am(s, "GetTotalGravity", (object x, List<Var> a) => vVec(SCtl(x).GetTotalGravity()));
				am(s, "GetShipSpeed", (object x, List<Var> a) => SCtl(x).GetShipSpeed());
				am(s, "TryGetPlanetPosition", (object x, List<Var> a) =>
				{
					Vector3D pos;
					if (SCtl(x).TryGetPlanetPosition(out pos)) return vVec(pos);
					return null;
				});
				#endregion //Geometry

				ap(s, "CanControlShip", (object x) => SCtl(x).CanControlShip);
				ap(s, "ControlThrusters", (object x) => SCtl(x).ControlThrusters, (object x, Var v) => SCtl(x).ControlThrusters = v);
				ap(s, "ControlWheels", (object x) => SCtl(x).ControlWheels, (object x, Var v) => SCtl(x).ControlWheels = v);
				ap(s, "DampenersOverride", (object x) => SCtl(x).DampenersOverride, (object x, Var v) => SCtl(x).DampenersOverride = v);
				ap(s, "HandBrake", (object x) => SCtl(x).HandBrake, (object x, Var v) => SCtl(x).HandBrake = v);
				ap(s, "HasWheels", (object x) => SCtl(x).HasWheels);
				ap(s, "IsMainCockpit", (object x) => SCtl(x).IsMainCockpit, (object x, Var v) => SCtl(x).IsMainCockpit = v);
				ap(s, "IsUnderControl", (object x) => SCtl(x).IsUnderControl);
				ap(s, "RollIndicator", (object x) => SCtl(x).RollIndicator);
				ap(s, "ShowHorizonIndicator", (object x) => SCtl(x).ShowHorizonIndicator, (object x, Var v) => SCtl(x).ShowHorizonIndicator = v);

				am(s, "CalculateShipMass", (object x, List<Var> a) => vShipMass(SCtl(x).CalculateShipMass()));
				am(s, "TryGetPlanetElevation", (object x, List<Var> a) =>
				{
					double d;
					if (SCtl(x).TryGetPlanetElevation(v2e<MyPlanetElevation>(a[0]), out d)) return d;
					return null;
				});

			}
			#endregion //Ship Controller
			#region Ship Tools
			void sSDri(SysVar s)
			{
				ap(s, "UseConveyorSystem", (object x) => SDri(x).UseConveyorSystem, (object x, Var v) => SDri(x).UseConveyorSystem = v);
			}
			void sSGri(SysVar s) { sSTB(s); }
			void sSWel(SysVar s)
			{
				sSTB(s);
				ap(s, "HelpOthers", (object x) => SWel(x).HelpOthers, (object x, Var v) => SWel(x).HelpOthers = v);
			}
			void sSTB(SysVar s)
			{
				ap(s, "UseConveyorSystem", (object x) => STB(x).UseConveyorSystem, (object x, Var v) => STB(x).UseConveyorSystem = v);
			}
			#endregion //Ship Tools
			#region Guns
			void sSGG(SysVar s)
			{
				sUCG(s);
				ap(s, "UseConveyorSystem", (object x) => SGG(x).UseConveyorSystem);
			}
			#endregion //Guns
			#region Missiles
			void sSML(SysVar s)
			{
				sUCG(s);
				ap(s, "UseConveyorSystem", (object x) => SML(x).UseConveyorSystem);
			}
			// TODO: What type name is this, for switch() in vBlock
			void sSMLR(SysVar s)
			{
				sUCG(s);
				sSML(s);
			}
			#endregion //Missiles

			#region Block/Item Definitions
			#region Inventory Items
			#region Store Block
			// MyStoreQueryItem
			Var vSQ(MyStoreQueryItem it)
			{
				Var r = th.mkv('a');
				r.d["Amount"] = it.Amount;
				r.d["Id"] = it.Id;  // Id of the offer/order, not the item

				r.d["ItemId"] = vDef(it.ItemId);
				r.d["PricePerUnit"] = it.PricePerUnit;
				return r;
				// Need to fully qualify this namespace in game
				//VRage.ObjectBuilders.SerializableDefinitionId
			}
			// MyStoreItemDataSimple
			MyStoreItemDataSimple v2SI(Var it) => new MyStoreItemDataSimple(v2Def(it["ItemId"]), it["Amount"], it["PricePerUnit"]);
			void sSto(SysVar s)
			{
				am(s, "CancelStoreItem", (object x, List<Var> a) => Sto(x).CancelStoreItem(a[0])); // offer/order id, not item id
				am(s, "GetPlayerStoreItems", (object x, List<Var> a) =>
				{
					var L = new List<MyStoreQueryItem>();
					Sto(x).GetPlayerStoreItems(L);
					var r = th.mkv('a');
					int i = 0;
					foreach (var q in L) r[i++] = vSQ(q);
					return r;
				});
				am(s, "InsertOffer", (object x, List<Var> a) =>
				{
					long id;
					Sto(x).InsertOffer(v2SI(a[0]), out id);
					return id;
				});
				am(s, "InsertOrder", (object x, List<Var> a) =>
				{
					long id;
					Sto(x).InsertOrder(v2SI(a[0]), out id);
					return id;
				});
				//am(s, "", (object x, List<Var> a) => Sto(x).);
				//Sto()
				// TODO: Item definition stuff
				//am(s, "CancelStoreItem", (object x, List<Var> a) => { Sto(x).CancelStoreItem(a[0]); return null;});
				//am(s, "GetPlayerStoreItems", (object x, List<Var> a) => { Sto(x).GetPlayerStoreItems; return null;});
				//am(s, "InsertOffer", (object x, List<Var> a) => { Sto(x).InsertOffer; return null;});
				//am(s, "InsertOrder", (object x, List<Var> a) => { Sto(x).InsertOrder; return null;});
				////var s = new MyStoreItemDataSimple(;
				//s.
			}
			#endregion // Store Block
			#endregion //Inventory Items
			#endregion // Block/Item Definitions

			void sTB(SysVar s)
			{
				// IMyTerminalBlock
				// Right now this is handled by vBlock() since everything we can resolve inherits from this
			}

			// Stub to make sprites dependent on geometry
			#region Geometry
			#region Sprites
			// I think we need at least one line here even if it's blank
			#endregion
			#endregion


			#region Text
			void sTP(SysVar s)
			{
				sTS(s);
				//ap(s, "ShowOnScreen", (object x) => TP(x).ShowOnScreen.ToString()); //!depr
				//ap(s, "ShowText", (object x) => TP(x).ShowText); //!depr

				//am(s, "GetPrivateText", (object x, List<Var> a) => TP(x).GetPrivateText()); //!dep
				//am(s, "GetPrivateTitle", (object x, List<Var> a) => TP(x).GetPrivateTitle()); //!dep
				//am(s, "GetPublicText", (object x, List<Var> a) => TP(x).GetPublicText()); //!dep
				am(s, "GetPublicTitle", (object x, List<Var> a) => TP(x).GetPublicTitle());
				am(s, "WritePublicTitle", (object x, List<Var> a) => TP(x).WritePublicTitle(a[0], a.Count >= 2 ? a[1].tr : false));
				//am(s, "", (object x, List<Var> a) => TP(x).ReadPublicText();
				//am(s, "", (object x, List<Var> a) => TP(x).SetShowOnScreen);
				//am(s, "", (object x, List<Var> a) => TP(x).ShowPrivateTextOnScreen);
				//am(s, "", (object x, List<Var> a) => TP(x).ShowPublicTextOnScreen);
				//am(s, "", (object x, List<Var> a) => TP(x).ShowTextureOnScreen);
				//am(s, "", (object x, List<Var> a) => TP(x).WritePrivateText);
				//am(s, "", (object x, List<Var> a) => TP(x).WritePrivateTitle);
				//am(s, "", (object x, List<Var> a) => TP(x).WritePublicText);
				//am(s, "", (object x, List<Var> a) => TP(x).WritePublicTitle);
			}

			IMyTextSurface TS(object cx) { return (cx as BCX).b as IMyTextSurface; }
			Var vTS(IMyTextSurface s)
			{
				Var r = SysVar.New(s, th);
				sTS(r.sy);
				return r;
			}

			#region Sprites
			//MySprite Spr(object x) => (MySprite)x;
			//MySprite vSpr(MySprite sp)
			//{
			//	Var r = SysVar.New(sp, th);
			//	var s = r.sy;
			//	ap(s, "Type", (object x) => Spr(x).Type.ToString(), (object x, Var v)=>Spr(x).Type=v2e<SpriteType>(v));
			//	ap(s, "", (object x) => Spr(x)., (object x, Var v)=>Spr(x).=v);
			//	ap(s, "", (object x) => Spr(x)., (object x, Var v)=>Spr(x).=v);
			//	ap(s, "", (object x) => Spr(x)., (object x, Var v)=>Spr(x).=v);
			//	ap(s, "", (object x) => Spr(x)., (object x, Var v)=>Spr(x).=v);
			//	ap(s, "", (object x) => Spr(x)., (object x, Var v)=>Spr(x).=v);
			//	ap(s, "", (object x) => Spr(x)., (object x, Var v)=>Spr(x).=v);
			//}
			//MySpriteDrawFrame SDF(object x) => (MySpriteDrawFrame)x;
			//Var vSDF (MySpriteDrawFrame f)
			//{
			//	Var r = SysVar.New(f, th); // th.mkv('a');
			//	var s = r.sy;
			//	am(s, "Add", (object x, List<Var> a) => SDF(x).);
			//	am(s, "", (object x, List<Var> a) => SDF(x).);
			//	am(s, "", (object x, List<Var> a) => SDF(x).);
			//	am(s, "", (object x, List<Var> a) => SDF(x).);
			//	am(s, "", (object x, List<Var> a) => SDF(x).);
			//	am(s, "", (object x, List<Var> a) => SDF(x).);
			//	am(s, "", (object x, List<Var> a) => SDF(x).);
			//	am(s, "", (object x, List<Var> a) => SDF(x).);
			//	am(s, "", (object x, List<Var> a) => SDF(x).);
			//}
			#endregion //Sprites

			void sTS(SysVar s)
			{
				ap(s, "Alignment", (object x) => TS(x).Alignment.ToString(), (object x, Var v) => TS(x).Alignment = v2e<TextAlignment>(v));
				ap(s, "BackgroundAlpha", (object x) => TS(x).BackgroundAlpha, (object x, Var v) => TS(x).BackgroundAlpha = (byte)v);
				ap(s, "BackgroundColor", (object x) => TS(x).BackgroundColor.PackedValue, (object x, Var v) => TS(x).BackgroundColor = new Color((uint)v));
				ap(s, "ChangeInterval", (object x) => TS(x).ChangeInterval, (object x, Var v) => TS(x).ChangeInterval = v);
				ap(s, "ContentType", (object x) => TS(x).ContentType.ToString(), (object x, Var v) => TS(x).ContentType = v2e<ContentType>(v));
				ap(s, "CurrentlyShownImage", (object x) => TS(x).CurrentlyShownImage);
				ap(s, "DisplayName", (object x) => TS(x).DisplayName);
				ap(s, "Font", (object x) => TS(x).Font, (object x, Var v) => TS(x).Font = v);
				ap(s, "FontColor", (object x) => TS(x).FontColor.PackedValue, (object x, Var v) => TS(x).FontColor = new Color((uint)v));
				ap(s, "FontSize", (object x) => TS(x).FontSize, (object x, Var v) => TS(x).FontSize = v);
				ap(s, "Name", (object x) => TS(x).Name);
				ap(s, "PreserveAspectRatio", (object x) => TS(x).PreserveAspectRatio, (object x, Var v) => TS(x).PreserveAspectRatio = v);
				ap(s, "Script", (object x) => TS(x).Script, (object x, Var v) => TS(x).Script = v);
				ap(s, "ScriptBackgroundColor", (object x) => TS(x).ScriptBackgroundColor.PackedValue, (object x, Var v) => TS(x).ScriptBackgroundColor = new Color((uint)v));
				ap(s, "ScriptForegroundColor", (object x) => TS(x).ScriptForegroundColor.PackedValue, (object x, Var v) => TS(x).ScriptForegroundColor = new Color((uint)v));
				ap(s, "TextPadding", (object x) => TS(x).TextPadding, (object x, Var v) => TS(x).TextPadding = v);
				#region Geometry !nodep
				ap(s, "TextureSize", (object x) => vVec2f(TS(x).TextureSize));
				ap(s, "SurfaceSize", (object x) => vVec2f(TS(x).SurfaceSize));
				#endregion

				am(s, "AddImagesToSelection", (object x, List<Var> a) =>
				{
					if (a.Count < 1 || a[0].a == null) return null;
					var ims = new List<string>();
					for (var i = 0; i < a[0].a.Count; i++) { ims.Add(a[0][i]); }
					TS(x).AddImagesToSelection(ims, a.Count >= 2 ? a[1].tr : false);
					return null;
				});
				am(s, "AddImageToSelection", (object x, List<Var> a) => { TS(x).AddImageToSelection(a[0], a.Count >= 2 ? a[1].tr : false); return null; });
				am(s, "ClearImagesFromSelection", (object x, List<Var> a) => { TS(x).ClearImagesFromSelection(); return null; });

				#region Sprites
				//// TODO: Sprites
				////MySpriteDrawFrame d;
				//am(s, "DrawFrame", (object x, List<Var> a) => { TS(x).DrawFrame(); return null;});
				//am(s, "GetSprites", (object x, List<Var> a) =>
				//{
				//	var L = new List<string>();
				//	TS(x).GetSprites(L);
				//	int i = 0;
				//	Var r = th.mkv('a');
				//	foreach (var q in L) r[i++] = q;
				//	return r;
				//});
				#endregion // Sprites

				am(s, "GetFonts", (object x, List<Var> a) =>
				{
					var l = new List<string>();
					TS(x).GetFonts(l);
					Var r = th.mkv('a');
					foreach (var f in l) { r.a.Add(f); }
					return r;
				});
				am(s, "GetScripts", (object x, List<Var> a) =>
				{
					var l = new List<string>();
					Var r = th.mkv('a');
					TS(x).GetScripts(l);
					foreach (var scr in l) { r.a.Add(scr); }
					return r;
				});
				am(s, "GetSelectedImages", (object x, List<Var> a) =>
				{
					Var r = th.mkv('a');
					var l = new List<string>();
					TS(x).GetSelectedImages(l);
					foreach (var im in l) { r.a.Add(im); }
					return r;
				});

				am(s, "GetText", (object x, List<Var> a) => TS(x).GetText());
				#region Geometry !nodep
				am(s, "MeasureStringInPixels", (object x, List<Var> a) => vVec2f(TS(x).MeasureStringInPixels(new StringBuilder(a[0].str), a[1], a[2])));
				#endregion
				am(s, "ReadText", (object x, List<Var> a) =>
				{
					var sb = new StringBuilder(a[0].s);
					TS(x).ReadText(sb, a.Count >= 2 ? a[1].tr : false);
					a[0].s = sb.ToString();
					return a[0];
				});
				am(s, "RemoveImageFromSelection", (object x, List<Var> a) => { TS(x).RemoveImageFromSelection(a[0], a.Count >= 2 ? a[1].tr : false); return null; });
				am(s, "RemoveImagesFromSelection", (object x, List<Var> a) =>
				{
					var l = new List<string>();
					for (int i = 0; i < a[0].a.Count; i++) { l.Add(a[0][i]); }
					TS(x).RemoveImagesFromSelection(l, a.Count >= 2 ? a[1].tr : false);
					return null;
				});
				am(s, "WriteText", (object x, List<Var> a) => { TS(x).WriteText(a[0], a.Count >= 2 ? a[1].tr : false); return null; });
			}
			IMyTextSurfaceProvider TSP(object cx) { return (cx as BCX).b as IMyTextSurfaceProvider; }
			Var vTSP(IMyTextSurfaceProvider p)
			{
				Var r = SysVar.New(p, th);
				sTSP(r.sy);
				return r;
			}
			void sTSP(SysVar s)
			{
				ap(s, "SurfaceCount", (object x) => TSP(x).SurfaceCount);
				am(s, "GetSurface", (object x, List<Var> a) => vTS(TSP(x).GetSurface((int)a[0])));
			}
			#endregion //Text

			// Various engines/thrusters are all MyThrust
			#region Thrust
			IMyThrust Thr(object cx) { return cx as IMyThrust; }
			Var vThr(IMyThrust t)
			{
				Var r = SysVar.New(t, th);
				sThr(r.sy);
				return r;
			}
			void sThr(SysVar s)
			{
				ap(s, "CurrentThrust", (object x) => Thr(x).CurrentThrust);
				#region Geometry !nodep
				ap(s, "GridThrustDirection", (object x) => vVec(Thr(x).GridThrustDirection));
				#endregion
				ap(s, "MaxEffectiveThrust", (object x) => Thr(x).MaxEffectiveThrust);
				ap(s, "MaxThrust", (object x) => Thr(x).MaxThrust);
				ap(s, "ThrustOverride", (object x) => Thr(x).ThrustOverride, (object x, Var v) => Thr(x).ThrustOverride = v);
				ap(s, "ThrustOverridePercentage", (object x) => Thr(x).ThrustOverridePercentage, (object x, Var v) => Thr(x).ThrustOverridePercentage = v);
			}
			#endregion //Thrust

			#region Comms
			// Unicast Listener
			void sUL(SysVar s)
			{
				sMP(s);
			}

			// Is IMyUnicastListener a block? No.
			Var vUL(IMyUnicastListener u)
			{
				Var r = th.mkv();
				SysVar s = new SysVar(u);
				r.sy = s;
				sUL(s);
				return r;
			}
			#endregion

			#region Upgrades
			void sUB(SysVar s)
			{
				ap(s, "UpgradeCount", (object x) => UB(x).UpgradeCount);
				am(s, "GetUpgrades", (object x, List<Var> a) =>
				{
					Var r = th.mkv('a');
					var d = new Dictionary<string, float>();
					UB(x).GetUpgrades(out d);
					foreach (var u in d) { r.d[u.Key] = u.Value; }
					return r;
				});
			}

			// UpgradeModuleInfo is prohibited... why
			//Var vUMI(MyUpgradeModuleInfo i)
			//{
			//	Var r = th.mkv('a');
			//	r["Modifier"] = i.Modifier;
			//	r["ModifierType"] = i.ModifierType.ToString();
			//	r["UpgradeType"] = i.UpgradeType;
			//	return r;
			//}
			
			void sUM(SysVar s)
			{
				ap(s, "Connections", (object x) => UM(x).Connections);
				ap(s, "UpgradeCount", (object x) => UM(x).UpgradeCount);
				//am(s, "GetUpgradeList", (object x, List<Var> a) =>
				//{
				//	//var i = new MyUpgradeModuleInfo;
				//	//i.ModifierType == VRage.Game.ObjectBuilders.Definitions.MyUpgradeModifierType.
				//	//i.UpgradeType
				//	List<MyUpgradeModuleInfo> l;
				//	UM(x).GetUpgradeList(out l);
				//	Var r = th.mkv('a');
				//	foreach (var u in l)
				//	{
				//		Var lv = th.mkv('a');
				//		lv.d["Modifier"] = u.Modifier;
				//		lv.d["ModifierType"] = u.ModifierType.ToString();
				//		lv.d["UpgradeType"] = u.UpgradeType;
				//		//r.a.Add(vUMI(u));
				//		r.a.Add(lv);
				//	}
				//	return r;
				//});
			}
			#endregion //Upgrades
			#region Guns
			void sUCG(SysVar s)
			{
				ap(s, "IsShooting", (object x) => UCG(x).IsShooting);
			}
			#endregion
			#region Warhead
			void sWar(SysVar s)
			{
				ap(s, "DetonationTime", (object x) => War(x).DetonationTime, (object x, Var v) => War(x).DetonationTime = v);
				ap(s, "IsArmed", (object x) => War(x).IsArmed, (object x, Var v) => War(x).IsArmed = v);
				ap(s, "IsCountingDown", (object x) => War(x).IsCountingDown);

				am(s, "Detonate", (object x, List<Var> a) => { War(x).Detonate(); return null; });
				am(s, "StartCountdown", (object x, List<Var> a) => War(x).StartCountdown());
				am(s, "StopCountdown", (object x, List<Var> a) => War(x).StopCountdown());
			}
			#endregion
			#region Wheels
			void sWhe(SysVar s)
			{
				sMR(s);
				sATB(s);
			}
			#endregion

			// SpaceEngineers.Game.dll --> namespace SpaceEngineers.Game.ModAPI (.Ingame)
			#region Air Vent
			IMyAirVent AV(object x) => ((x as BCX).b) as IMyAirVent;
			#endregion
			#region Artificial Mass Block
			IMyArtificialMassBlock AMB(object x) => ((x as BCX).b) as IMyArtificialMassBlock;
			#endregion
			#region Buttons
			IMyButtonPanel BP(object x) => ((x as BCX).b) as IMyButtonPanel;
			#endregion
			#region Control Panel
			IMyControlPanel CP(object x) => ((x as BCX).b) as IMyControlPanel;
			#endregion
			#region Gravity Generator
			IMyGravityGenerator GrG(object x) => ((x as BCX).b) as IMyGravityGenerator;
			IMyGravityGeneratorBase GrGB(object x) => ((x as BCX).b) as IMyGravityGeneratorBase;
			IMyGravityGeneratorSphere GrGS(object x) => ((x as BCX).b) as IMyGravityGeneratorSphere;
			#endregion
			//#region Lights
			//IMyInteriorLight IL(object x) => ((x as BCX).b) as IMyInteriorLight;
			//#endregion
			#region Landing Gear
			IMyLandingGear LG(object x) => ((x as BCX).b) as IMyLandingGear;
			#endregion
			#region Turrets
			IMyLargeConveyorTurretBase LCTB(object x) => ((x as BCX).b) as IMyLargeConveyorTurretBase;
			IMyLargeGatlingTurret LGT(object x) => ((x as BCX).b) as IMyLargeGatlingTurret;
			IMyLargeInteriorTurret LIT(object x) => ((x as BCX).b) as IMyLargeInteriorTurret;
			IMyLargeMissileTurret LMT(object x) => ((x as BCX).b) as IMyLargeMissileTurret;
			#endregion
			#region Medical Room
			IMyMedicalRoom MedR(object x) => ((x as BCX).b) as IMyMedicalRoom;
			#endregion
			#region Oxygen Farm
			IMyOxygenFarm OxyF(object x) => ((x as BCX).b) as IMyOxygenFarm;
			#endregion
			#region Parachute
			IMyParachute Par(object x) => ((x as BCX).b) as IMyParachute;
			#endregion
			#region Safe Zone
			IMySafeZoneBlock SZ(object x) => ((x as BCX).b) as IMySafeZoneBlock;
			#endregion
			#region Merge Block
			IMyShipMergeBlock Mer(object x) => ((x as BCX).b) as IMyShipMergeBlock;
			#endregion
			#region Power Producers
			IMySolarPanel Sol(object x) => ((x as BCX).b) as IMySolarPanel;
			#endregion
			#region Sound Blocks
			IMySoundBlock Snd(object x) => ((x as BCX).b) as IMySoundBlock;
			#endregion
			#region Artificial Mass Block
			IMySpaceBall Bal(object x) => ((x as BCX).b) as IMySpaceBall;
			#endregion
			#region Timer Block
			IMyTimerBlock Tim(object x) => ((x as BCX).b) as IMyTimerBlock;
			#endregion
			#region Artificial Mass Block
			IMyVirtualMass VMa(object x) => ((x as BCX).b) as IMyVirtualMass;
			#endregion

			//Var vResSinkInf(MyResourceSinkInfo i)
			//{
			//	Var r = th.mkv('a');
			//	i.
			//	return r;
			//}
			//SpaceEngineers.Game
			//	SpaceEngineers.Game.ModAPI.Ingame

			#region Air Vent
			void sAV(SysVar s)
			{
				//ap(s, "GasInputPerSecond", (object x) => AV(x).GasInputPerSecond);
				//ap(s, "GasOutputPerSecond", (object x) => AV(x).GasOutputPerSecond);
				// TODO: Resources
				//ap(s, "", (object x) => AV(x).OxygenSinkInfo);
				//ap(s, "", (object x) => AV(x).SourceComp);


				ap(s, "CanPressurize", (object x) => AV(x).CanPressurize);
				ap(s, "Depressurize", (object x) => AV(x).Depressurize, (object x, Var v) => AV(x).Depressurize = v);
				//ap(s, "", (object x) => AV(x).IsDe);
				ap(s, "PressurizationEnabled", (object x) => AV(x).PressurizationEnabled);
				ap(s, "Status", (object x) => AV(x).Status.ToString());

				am(s, "GetOxygenLevel", (object x, List<Var> a) => AV(x).GetOxygenLevel());
				//am(s, "IsPressurized", (object x, List<Var> a) => AV(x).IsPressurized());

				//ap(s, "", (object x) => AV(x).);
				//am(s, "", (object x) => AV(x).);
			}
			#endregion
			#region Artificial Mass Block
			void sAMB(SysVar s) { }
			#endregion
			#region Buttons
			void sBP(SysVar s)
			{
				sTSP(s);
				ap(s, "AnyoneCanUse", (object x) => BP(x).AnyoneCanUse);
				am(s, "ClearCustomButtonName", (object x, List<Var> a) => { BP(x).ClearCustomButtonName(a[0]); return null; });
				am(s, "GetButtonName", (object x, List<Var> a) => BP(x).GetButtonName(a[0]));
				am(s, "HasCustomButtonName", (object x, List<Var> a) => BP(x).HasCustomButtonName(a[0]));
				am(s, "IsButtonAssigned", (object x, List<Var> a) => BP(x).IsButtonAssigned(a[0]));
				am(s, "SetCustomButtonName", (object x, List<Var> a) => { BP(x).SetCustomButtonName(a[0], a[1]); return null; });

				//ap(s, "", (object x) => AV(x).);
				//am(s, "", (object x) => AV(x).);
			}
			#endregion
			#region Control Panel
			void sCP(SysVar s) { }
			#endregion
			#region Gravity Generator
			void sGrG(SysVar s)
			{
				sGrGB(s);

				#region Geometry !nodep
				ap(s, "", (object x) => vVec(GrG(x).FieldSize), (object x, Var v) => GrG(x).FieldSize = v2vec(v));
				#endregion
			}
			void sGrGB(SysVar s)
			{
				ap(s, "GravityAcceleration", (object x) => GrGB(x).GravityAcceleration, (object x, Var v) => GrGB(x).GravityAcceleration = v);
				//ap(s, "Gravity", (object x) => GrGB(x).Gravity, (object x, Var v) => GrGB(x).Gravity = v);
			}
			void sGrGS(SysVar s)
			{
				sGrGB(s);
				ap(s, "Radius", (object x) => GrGS(x).Radius, (object x, Var v) => GrGS(x).Radius = v);
			}
			#endregion //Gravity Generator
			//#region Lights
			//void sIL(SysVar s)
			//{
			// It's just a lighting block
			//	sLB(s);
			//}
			//#endregion

			#region Landing Gear
			void sLG(SysVar s)
			{
				ap(s, "AutoLock", (object x) => LG(x).AutoLock, (object x, Var v) => LG(x).AutoLock = v);
				//ap(s, "", (object x) => LG(x).IsBreakable);
				ap(s, "IsLocked", (object x) => LG(x).IsLocked);
				ap(s, "", (object x) => LG(x).LockMode.ToString());

				am(s, "", (object x, List<Var> v) => { LG(x).Lock(); return null; });
				am(s, "", (object x, List<Var> v) => { LG(x).Unlock(); return null; });
				am(s, "", (object x, List<Var> v) => { LG(x).ResetAutoLock(); return null; });
				am(s, "", (object x, List<Var> v) => { LG(x).ToggleLock(); return null; });

				//ap(s, "", (object x) => LG(x)., (object x, Var v) => LG(x). = v);
				//am(s, "", (object x, List<Var> v) => LG(x).);

			}
			#endregion
			#region Turrets
			void sLCTB(SysVar s)
			{
				sLTB(s);
				sUCG(s);

				ap(s, "UseConveyorSystem", (object x) => LCTB(x).UseConveyorSystem);
				//ap(s, "UseConveyorSystem", (object x) => LCTB(x).UseConveyorSystem, (object x, Var v) => LG(x). = v);
			}
			void sLGT(SysVar s)
			{
				sLCTB(s);
				sLTB(s);
				sUCG(s);
			}
			void sLIT(SysVar s)
			{
				sLTB(s);
				sUCG(s);
			}
			void sLMT(SysVar s)
			{
				sLCTB(s);
				sLTB(s);
				sUCG(s);
			}
			#endregion
			#region Medical Room
			void sMedR(SysVar s) { }
			#endregion
			#region Production Blocks
			void sSur(SysVar s)
			{
				sAss(s);
			}
			#endregion
			#region Oxygen Farm
			void sOxyF(SysVar s)
			{
				ap(s, "CanProduce", (object x) => OxyF(x).CanProduce);
				am(s, "GetOutput", (object x, List<Var> v) => OxyF(x).GetOutput());

				//ap(s, "", (object x) => LG(x)., (object x, Var v) => LG(x). = v);
				//am(s, "", (object x, List<Var> v) => LG(x).);
			}
			#endregion

			#region Parachute
			void sPar(SysVar s)
			{
				sDoor(s);
				ap(s, "Atmosphere", (object x) => Par(x).Atmosphere);
				ap(s, "Status", (object x) => Par(x).Status.ToString());
				ap(s, "OpenRatio", (object x) => Par(x).OpenRatio);

				am(s, "CloseDoor", (object x, List<Var> v) => { Par(x).CloseDoor(); return null; });
				am(s, "OpenDoor", (object x, List<Var> v) => { Par(x).OpenDoor(); return null; });
				am(s, "ToggleDoor", (object x, List<Var> v) => { Par(x).ToggleDoor(); return null; });
				#region Geometry !nodep
				am(s, "GetArtificialGravity", (object x, List<Var> v) => vVec(Par(x).GetArtificialGravity()));
				am(s, "GetNaturalGravity", (object x, List<Var> v) => vVec(Par(x).GetNaturalGravity()));
				am(s, "GetTotalGravity", (object x, List<Var> v) => vVec(Par(x).GetTotalGravity()));
				am(s, "GetVelocity", (object x, List<Var> v) => vVec(Par(x).GetVelocity()));
				am(s, "TryGetClosestPoint", (object x, List<Var> v) =>
				{
					var vc = new Vector3D?();
					if (Par(x).TryGetClosestPoint(out vc) && vc.HasValue) return vVec(vc.Value);
					return null;
				});
				//am(s, "", (object x, List<Var> v) => Par(x).);
				#endregion
				//am(s, "", (object x, List<Var> v) => Par(x).);

				//ap(s, "", (object x) => Par(x)., (object x, Var v) => Par(x). = v);
				//am(s, "", (object x, List<Var> v) => Par(x).);
			}
			#endregion
			#region Safe Zone
			void sSZ(SysVar s)
			{
				// Not accessible ingame
				//am(s, "EnableSafeZone", (object x, List<Var> a) => { SZ(x).EnableSafeZone(a[0]); return null;});
				//am(s, "IsSafeZoneEnabled", (object x, List<Var> a) => SZ(x).IsSafeZoneEnabled());
			}
			#endregion
			#region Merge Block
			void sMer(SysVar s)
			{

				ap(s, "IsConnected", (object x) => Mer(x).IsConnected);

				// not ingame
				//ap(s, "GridCount", (object x) => Mer(x).GridCount);
				//ap(s, "Other", (object x) => vBlock(Mer(x).Other));
			}
			#endregion
			#region Power Producers
			void sSol(SysVar s)
			{
				sPP(s);
			}
			#endregion
			#region Sound Blocks
			void sSnd(SysVar s)
			{
				ap(s, "Range", (object x) => Snd(x).Range, (object x, Var v) => Snd(x).Range = v);
				ap(s, "Volume", (object x) => Snd(x).Volume, (object x, Var v) => Snd(x).Volume = v);
				ap(s, "IsSoundSelected", (object x) => Snd(x).IsSoundSelected);
				ap(s, "LoopPeriod", (object x) => Snd(x).LoopPeriod, (object x, Var v) => Snd(x).LoopPeriod = v);
				ap(s, "SelectedSound", (object x) => Snd(x).SelectedSound, (object x, Var v) => Snd(x).SelectedSound = v);

				ap(s, "GetSounds", (object x) =>
				{
					// TODO: Template for returning a list of things, space saver
					Var r = th.mkv('a');
					var L = new List<string>();
					Snd(x).GetSounds(L);
					int i = 0;
					foreach (var sn in L) r[i++] = sn;
					return r;
				});
				ap(s, "Play", (object x) => { Snd(x).Play(); return null; });
				ap(s, "Stop", (object x) => { Snd(x).Stop(); return null; });


				//am(s, "", (object x, List<Var> v) => Par(x).);
				//am(s, "", (object x, List<Var> a) => { Cam(x).; return null;});
			}
			#endregion

			#region Artificial Mass Block
			void sBal(SysVar s) { sVMa(s); }
			#endregion

			#region Timer Block
			void sTim(SysVar s)
			{
				ap(s, "IsCountingDown", (object x) => Tim(x).IsCountingDown);
				ap(s, "TriggerDelay", (object x) => Tim(x).TriggerDelay, (object x, Var v) => Tim(x).TriggerDelay = v);
				ap(s, "Silent", (object x) => Tim(x).Silent, (object x, Var v) => Tim(x).Silent = v);

				am(s, "StartCountdown", (object x, List<Var> a) => { Tim(x).StartCountdown(); return null; });
				am(s, "StopCountdown", (object x, List<Var> a) => { Tim(x).StopCountdown(); return null; });
				am(s, "Trigger", (object x, List<Var> a) => { Tim(x).Trigger(); return null; });

				//ap(s, "", (object x) => Tim(x)., (object x, Var v)=>Tim(x).=v);
				//am(s, "", (object x, List<Var> a) => { Tim(x).; return null;});

			}
			#endregion
			#region Artificial Mass Block
			void sVMa(SysVar s)
			{
				ap(s, "VirtualMass", (object x) => VMa(x).VirtualMass);
			}
			#endregion
			//ap(s, "", (object x) => Cam(x)., (object x, Var v) => Cam(x). = v);
			//am(s, "", (object x, List<Var> a) => { Cam(x).; return null;});


			// Add missing blocks here




			#region Inventory Items
			#region Sorter
			MyInventoryItemFilter v2InvItemFilter(Var v)
			{
				if (v.ty == 'a') return new MyInventoryItemFilter(v["ItemId"], v["AllSubTypes"]);
				else return new MyInventoryItemFilter(v);
			}
			Var vInvItemFilter(MyInventoryItemFilter f)
			{
				Var r = th.mkv('a');
				r["ItemId"] = vDef(f.ItemId); // SubtypeId.String; // ToString();
				r["AllSubTypes"] = f.AllSubTypes;
				r["ItemType"] = vItemType(f.ItemType);
				return r;
			}
			#endregion //Sorter
			#endregion //Inventory Items

			#region Entities
			// <comp name="Entities">
			Var vDEI(MyDetectedEntityInfo d)
			{
				var r = th.mkv('a');
				var s = new SysVar(d);
				r.sy = s;
				#region Geometry !nodep
				r.d["BoundingBox"] = vAABB(d.BoundingBox);
				r.d["HitPosition"] = d.HitPosition == null ? null : vVec(d.HitPosition.Value);
				r.d["Orientation"] = vMat(d.Orientation);
				r.d["Position"] = vVec(d.Position);
				r.d["Velocity"] = vVec(d.Velocity);
				#endregion
				r.d["EntityId"] = d.EntityId;
				r.d["Name"] = d.Name;
				r.d["Relationship"] = d.Relationship.ToString();
				r.d["TimeStamp"] = d.TimeStamp;
				r.d["Type"] = d.Type.ToString();
				am(s, "IsEmpty", (object x, List<Var> a) => ((MyDetectedEntityInfo)x).IsEmpty());
				return r;
			}
			// </comp> Entities
			#endregion // Entities

			#region Cube Grid
			IMyCubeGrid Gr(object x) { return x as IMyCubeGrid; }
			Var vCubeGrid(IMyCubeGrid g)
			{
				//var r = new Var(th, 'a');
				//var r = th.mkv('a');
				var r = SysVar.New(g, th);
				var s = r.sy;
				//r.sy = new SysVar(g);
				// TODO: Fill out props and methods
				ap(s, "CustomName", (object x) => Gr(x).CustomName, (object x, Var v) => { Gr(x).CustomName = v; });
				ap(s, "GridSize", (object x) => Gr(x).GridSize);
				ap(s, "GridSizeEnum", (object x) => Gr(x).GridSizeEnum.ToString());
				ap(s, "IsStatic", (object x) => Gr(x).IsStatic);
				#region Geometry !nodep
				ap(s, "Max", (object x) => vVec(Gr(x).Max));
				ap(s, "Min", (object x) => vVec(Gr(x).Min));
				am(s, "CubeExists", (object x, List<Var> a) => Gr(x).CubeExists(v2vec3i(a[0])));
				am(s, "GetCubeBlock", (object x, List<Var> a) => vSlm(Gr(x).GetCubeBlock(v2vec3i(a[0]))));
				am(s, "GridIntegerToWorld", (object x, List<Var> a) => vVec(Gr(x).GridIntegerToWorld(v2vec3i(a[0]))));
				am(s, "IsSameConstructAs", (object x, List<Var> a) => a[0].sy == null ? false : Gr(x).IsSameConstructAs(Gr(a[0].sy.cx)));
				am(s, "WorldToGridInteger", (object x, List<Var> a) => vVec3i(Gr(x).WorldToGridInteger(v2vec(a[0]))));
				#endregion //Geometry

				// Template
				//am(s, "", (object x, List<Var> a) => Gr(x).;
				//ap(s, "", (object x) => Gr(x)., (object x, Var v)=> { Gr(x). = v; });

				return r;
			}
			#region Cube Block Info
			Var vSlm(IMySlimBlock b)
			{
				var r = th.mkv('a');
				#region Components !nodep
				var c = th.mkv('a');
				var cd = new Dictionary<string, int>();
				b.GetMissingComponents(cd);
				foreach (var p in cd) c[p.Key] = p.Value;
				r["MissingComponents"] = c;
				#endregion


				r["AccumulatedDamage"] = b.AccumulatedDamage;
				r["BlockDefinition"] = vDef(b.BlockDefinition);
				r["BuildIntegrity"] = b.BuildIntegrity;
				r["BuildLevelRatio"] = b.BuildLevelRatio;
				r["ColorMaskHSV"] = vVec(b.ColorMaskHSV);
				r["CubeGrid"] = vCubeGrid(b.CubeGrid);
				r["CurrentDamage"] = b.CurrentDamage;
				r["DamageRatio"] = b.DamageRatio;
				//r["FatBlock"] = b.FatBlock = //vBlock(b); // TODO: vCubeBlock? and de-suplicate vBlock
				r["HasDeformation"] = b.HasDeformation;
				r["IsDestroyed"] = b.IsDestroyed;
				r["IsFullIntegrity"] = b.IsFullIntegrity;
				r["IsFullyDismounted"] = b.IsFullyDismounted;
				r["Mass"] = b.Mass;
				r["MaxDeformation"] = b.MaxDeformation;
				r["MaxIntegrity"] = b.MaxIntegrity;
				r["OwnerId"] = b.OwnerId;
				#region Geometry !nodep
				r["Position"] = vVec(b.Position);
				#endregion
				r["ShowParts"] = b.ShowParts;
				//r["SkinSubtypeId"] = b.SkinSubtypeId.m_hash;
				r["SkinSubtypeId"] = b.SkinSubtypeId.ToString();
				r["StockpileAllocated"] = b.StockpileAllocated;
				r["StockpileEmpty"] = b.StockpileEmpty;


				return r;
			}
			#endregion // Cube Block Info
			#endregion //Cube Grid

			#region Inventory
			IMyInventory Inv(object x) { return x as IMyInventory; }
			Var vInv(IMyInventory y)
			{
				Var r = SysVar.New(y, th);
				SysVar s = r.sy;
				ap(s, "CurrentMass", (object x) => Inv(x).CurrentMass.RawValue / 1e6);
				ap(s, "CurrentVolume", (object x) => Inv(x).CurrentVolume.RawValue / 1e6);
				ap(s, "IsFull", (object x) => Inv(x).IsFull);
				ap(s, "ItemCount", (object x) => Inv(x).ItemCount);
				ap(s, "MaxVolume", (object x) => Inv(x).MaxVolume.RawValue / 1e6);
				#region Entities !nodep
				ap(s, "Owner", (object x) => vEntity(Inv(x).Owner));
				#endregion
				//ap(s, "", (object x) => Inv(x).);
				//var dfghsdg = new VRage.MyFixedPoint();

				am(s, "IsConnectedTo", (object x, List<Var> a) => Inv(x).IsConnectedTo(Inv(a[0].sy.cx)));
				am(s, "IsItemAt", (object x, List<Var> a) => Inv(x).IsItemAt((int)a[0]));


				#region Inventory Items
				am(s, "CanItemsBeAdded", (object x, List<Var> a) =>
				{
					var f = new MyFixedPoint();
					f.RawValue = (long)a[0] * 1000000;
					//MyItemType it = new MyItemType();
					//var ii = it.GetItemInfo();
					//ii.
					//return Inv(x).CanItemsBeAdded(f, ITy(a[1].sy.cx));
					return Inv(x).CanItemsBeAdded(f, v2ITy(a[1]));
				});
				//am(s, "CanTransferItemTo", (object x, List<Var> a) => Inv(x).CanTransferItemTo(Inv(a[0].sy.cx), ITy(a[1].sy.cx)));
				am(s, "CanTransferItemTo", (object x, List<Var> a) => Inv(x).CanTransferItemTo(Inv(a[0].sy.cx), v2ITy(a[1])));
				am(s, "ContainItems", (object x, List<Var> a) =>
				{
					var f = new MyFixedPoint();
					f.RawValue = (long)a[0] * 1000000;
					//return Inv(x).ContainItems(f, ITy(a[1].sy.cx));
					return Inv(x).ContainItems(f, v2ITy(a[1]));
				});
				am(s, "FindItem", (object x, List<Var> a) =>
				{
					//var n = Inv(x).FindItem(ITy(a[0].sy.cx));
					var n = Inv(x).FindItem(v2ITy(a[0]));
					if (n.HasValue) return vItm(n.Value);
					return null;
				});
				am(s, "GetAcceptedItems", (object x, List<Var> a) =>
				{
					Var vl = th.mkv('a');
					var l = new List<MyItemType>();
					Inv(x).GetAcceptedItems(l);
					foreach (var t in l)
					{
						vl.a.Add(vItemType(t));
					}
					return vl;
				});
				//am(s, "GetItemAmount", (object x, List<Var> a) => Inv(x).GetItemAmount(ITy(a[0].sy.cx)).RawValue / 1e6);
				am(s, "GetItemAmount", (object x, List<Var> a) => Inv(x).GetItemAmount(v2ITy(a[0])).RawValue / 1e6);
				am(s, "GetItemAt", (object x, List<Var> a) =>
				{
					var n = Inv(x).GetItemAt((int)a[0]);
					if (n.HasValue) return vItm(n.Value);
					return null;
				});
				am(s, "GetItemByID", (object x, List<Var> a) =>
				{
					var n = Inv(x).GetItemByID((uint)a[0]);
					if (n.HasValue) return vItm(n.Value);
					return null;
				});
				am(s, "GetItems", (object x, List<Var> a) =>
				{
					var ram = th.mkv('a');
					var l = new List<MyInventoryItem>();
					Inv(x).GetItems(l);
					foreach (var i in l) ram.a.Add(vItm(i));
					return ram;
				});
				am(s, "TransferItemFrom", (object x, List<Var> a) =>
				{
					var f = new MyFixedPoint();
					f.RawValue = (long)(a[2] * 1000000);
					//return Inv(x).TransferItemFrom(Inv(a[0].sy.cx), Itm(a[1].sy.cx), f);
					return Inv(x).TransferItemFrom(Inv(a[0].sy.cx), v2Itm(a[1]), f);
				});
				am(s, "TransferItemTo", (object x, List<Var> a) =>
				{
					var f = new MyFixedPoint();
					f.RawValue = a[2] * 1000000;
					//print(console, a[1].sy == null ? "sy null\n" : "sy not null\n");
					//print(console, a[1].sy.cx == null ? "cx null\n" : "cx not null\n");
					//return Inv(x).TransferItemTo(Inv(a[0].sy.cx), Itm(a[1].sy.cx), f);
					return Inv(x).TransferItemTo(Inv(a[0].sy.cx), v2Itm(a[1]), f);
				});
				#endregion // Inventory Items
				//am(s, "", (object x, List<Var> a) => Inv(x).);

				return r;
			}

			#region Inventory Items
			MyInventoryItem Itm(object x) { return ((MyInventoryItem)x); }
			Var vItm(MyInventoryItem i)
			{
				//Var r = SysVar.New(item, th);
				//SysVar s = r.sy;
				//ap(s, "Amount", (object x) => Itm(x).Amount.RawValue /1e6);
				//ap(s, "ItemId", (object x) => Itm(x).ItemId);
				//ap(s, "Type", (object x) => vItemType(Itm(x).Type));
				////ap(set, "", (object x) => Itm(x).);
				//item.

				Var r = th.mkv('a');
				r["Amount"] = i.Amount.RawValue / 1e6;
				r["ItemId"] = i.ItemId;
				r["Type"] = vItemType(i.Type);
				return r;
			}
			MyInventoryItem v2Itm(Var v)
			{
				var f = new MyFixedPoint();
				f.RawValue = (long)(v["Amount"] * 1000000);
				//return new MyInventoryItem(ITy(v["Type"].sy.cx), (uint)v["ItemId"], f);
				return new MyInventoryItem(v2ITy(v["Type"]), (uint)v["ItemId"], f);
			}
			#endregion // Inventory Items
			#endregion // Inventory

			#region Entities
			IMyEntity Ent(object x) => x as IMyEntity;
			Var vEntity(IMyEntity e)
			{
				Var r = SysVar.New(e, th);
				SysVar s = r.sy;
				// .Components?
				ap(s, "DisplayName", (object x) => Ent(x).DisplayName);
				ap(s, "EntityId", (object x) => Ent(x).EntityId);
				ap(s, "Name", (object x) => Ent(x).Name);
				#region Geometry !nodep
				ap(s, "WorldAABB", (object x) => vAABB(Ent(x).WorldAABB));
				ap(s, "WorldAABBHr", (object x) => vAABB(Ent(x).WorldAABBHr));
				ap(s, "WorldMatrix", (object x) => vMat(Ent(x).WorldMatrix));
				ap(s, "WorldVolume", (object x) => vBoundingSphere(Ent(x).WorldVolume));
				ap(s, "WorldVolumeHr", (object x) => vBoundingSphere(Ent(x).WorldVolumeHr));
				am(s, "GetPosition", (object x, List<Var> a) => vVec(Ent(x).GetPosition()));
				#endregion

				// <comp name="Inventory Items">
				#region Inventory !nodep
				ap(s, "HasInventory", (object x) => Ent(x).HasInventory);
				ap(s, "InventoryCount", (object x) => Ent(x).InventoryCount);
				am(s, "GetInventory", (object x, List<Var> a) =>
				{
					if (a.Count > 0) return vInv(Ent(x).GetInventory((int)a[0]));
					return vInv(Ent(x).GetInventory());
				});
				#endregion // Inventory
				// </comp>
				//am(s, "", (object x, List<Var> args) => { });

				return r;
			}
			#endregion // Entities

			// <comp name="Inventory Items">
			#region Inventory Items
			MyItemType ITy(object x) => (MyItemType)x;
			Var vItemType(MyItemType t)
			{
				Var r = SysVar.New(t, th);
				SysVar s = r.sy;
				ap(s, "SubtypeId", (object x) => ITy(x).SubtypeId);
				ap(s, "TypeId", (object x) => ITy(x).TypeId);
				//ap(s, "", (object x) => ITy(x).);
				am(s, "CompareTo", (object x, List<Var> a) => ITy(x).CompareTo(ITy(a[0].sy.cx)));
				am(s, "GetItemInfo", (object x, List<Var> a) => vItmInf(ITy(x).GetItemInfo()));
				//am(s, "", (object x, List<Var> a) => { });
				return r;
			}
			MyItemType v2ITy(Var v)
			{
				return new MyItemType(v["TypeId"], v["SubtypeId"]);
			}

			Var vItmInf(MyItemInfo i)
			{
				Var r = th.mkv('a');
				r["IsAmmo"] = i.IsAmmo;
				r["IsComponent"] = i.IsComponent;
				r["IsIngot"] = i.IsIngot;
				r["IsOre"] = i.IsOre;
				r["IsTool"] = i.IsTool;
				r["Mass"] = i.Mass;
				r["MaxStackAmount"] = i.MaxStackAmount.RawValue / 1e6;
				#region Geometry !nodep
				r["Size"] = vVec(i.Size);
				#endregion
				r["UsesFractions"] = i.UsesFractions;
				r["Volume"] = i.Volume;
				return r;
			}
			MyItemInfo v2II(Var v)
			{
				MyItemInfo i = new MyItemInfo();
				i.IsAmmo = v["IsAmmo"];
				i.IsComponent = v["IsComponent"];
				i.IsIngot = v["IsIngot"];
				i.IsOre = v["IsOre"];
				i.IsTool = v["IsTool"];
				i.Mass = v["Mass"];
				i.MaxStackAmount.RawValue = (long)(v["MaxStackAmount"] * 1e6);
				i.Size.X = v["Size"]["X"];
				i.Size.Y = v["Size"]["Y"];
				i.Size.Z = v["Size"]["Z"];
				i.UsesFractions = v["UsesFractions"];
				i.Volume = v["Volume"];
				return i;
			}
			// </comp> Inventory Items
			#endregion // Inventory Items

			//class Box<T>
			//{
			//	public Box(T val) { v = val; }
			//	T v;
			//	public static implicit operator T(Box<T> b) { return b.v; }
			//	public static implicit operator Box<T>(T val) { return new Box<T>(val); }
			//}

			#region Geometry
			Vector3D Vc(object x) { return (Vector3D)x; }
			public Var vVec(Vector3D v)
			{
				// TODO: Calculated properties
				//SysVar s = new SysVar(vec);
				//Var r = new Var('a');
				Var r = th.mkv('a');
				//r.sy = s;
				r.d["X"] = v.X;
				r.d["Y"] = v.Y;
				r.d["Z"] = v.Z;
				//r.sy = new SysVar(new Box<Vector3D>(ob));
				//r.sy.AddProp("x", (object x) => ((Vector3D)x).X, (object x, Var v) => ((Vector3D)x).X = v);
				return r;
			}

			MyBlockOrientation BOr(object x) => (MyBlockOrientation)x;
			Var vBlockOrientation(MyBlockOrientation ori)
			{
				Var r = new Var(th, 'a');
				r.d["Forward"] = ori.Forward.ToString();
				r.d["Up"] = ori.Up.ToString();
				r.d["Left"] = ori.Left.ToString();
				return r;
			}

			Var vAABB(BoundingBoxD bb)
			{
				// TODO: Calculated properties
				Var r = th.mkv('a');
				// Actual data
				r.d["Max"] = vVec(bb.Max);
				r.d["Min"] = vVec(bb.Min);

				// Calculated properties - assuming AABBs are read only,
				// otherwise need to actually make setter calls
				r.d["Center"] = vVec(bb.Center);
				r.d["Extents"] = vVec(bb.Extents);
				r.d["HalfExtents"] = vVec(bb.HalfExtents);
				r.d["Matrix"] = vMat(bb.Matrix);
				r.d["Perimeter"] = bb.Perimeter;
				r.d["Size"] = vVec(bb.Size);
				r.d["SurfaceArea"] = bb.SurfaceArea;
				r.d["Valid"] = bb.Valid;
				r.d["Volume"] = bb.Volume;
				return r;
			}

			//MatrixD Mx(object x) => (MatrixD)x;
			public Var vMat(MatrixD m)
			{
				// TODO: Calculated properties
				Var r = th.mkv('a');
				r.d["M11"] = m.M11;
				r.d["M12"] = m.M11;
				r.d["M13"] = m.M11;
				r.d["M14"] = m.M11;
				r.d["M21"] = m.M11;
				r.d["M22"] = m.M11;
				r.d["M23"] = m.M11;
				r.d["M24"] = m.M11;
				r.d["M31"] = m.M11;
				r.d["M32"] = m.M11;
				r.d["M33"] = m.M11;
				r.d["M34"] = m.M11;
				r.d["M41"] = m.M11;
				r.d["M42"] = m.M11;
				r.d["M43"] = m.M11;
				r.d["M44"] = m.M11;
				return r;
			}

			#region Matrix Math
			public MatrixD v2Mat(Var v)
			{
				MatrixD m = new MatrixD();
				m.M11 = v["M11"];
				m.M12 = v["M12"];
				m.M13 = v["M13"];
				m.M14 = v["M14"];
				m.M21 = v["M21"];
				m.M22 = v["M22"];
				m.M23 = v["M23"];
				m.M24 = v["M24"];
				m.M31 = v["M31"];
				m.M32 = v["M32"];
				m.M33 = v["M33"];
				m.M34 = v["M34"];
				m.M41 = v["M41"];
				m.M42 = v["M42"];
				m.M43 = v["M43"];
				m.M44 = v["M44"];
				return m;
			}

			public Vector3D mmulv(MatrixD m, Vector3D v) => new Vector3D(
				m.M11 * v.X + m.M12 * v.Y + m.M13 * v.Z + m.M14,
				m.M21 * v.X + m.M22 * v.Y + m.M23 * v.Z + m.M24,
				m.M31 * v.X + m.M32 * v.Y + m.M33 * v.Z + m.M34
			);

			public MatrixD minv(MatrixD m)
			{
				var r = new MatrixD();
				r.M11 = 0
				  + (m.M22 * m.M33 * m.M44) + (m.M32 * m.M43 * m.M24) + (m.M42 * m.M23 * m.M34)
				  - (m.M42 * m.M33 * m.M24) - (m.M32 * m.M23 * m.M44) - (m.M22 * m.M43 * m.M34);
				r.M21 = 0
				  - (m.M21 * m.M33 * m.M44) - (m.M31 * m.M43 * m.M24) - (m.M41 * m.M23 * m.M34)
				  + (m.M41 * m.M33 * m.M24) + (m.M31 * m.M23 * m.M44) + (m.M21 * m.M43 * m.M34);
				r.M31 = 0
				  + (m.M21 * m.M32 * m.M44) + (m.M31 * m.M42 * m.M24) + (m.M41 * m.M22 * m.M34)
				  - (m.M41 * m.M32 * m.M24) - (m.M31 * m.M22 * m.M44) - (m.M21 * m.M42 * m.M34);
				r.M41 = 0
				  - (m.M21 * m.M32 * m.M43) - (m.M31 * m.M42 * m.M23) - (m.M41 * m.M22 * m.M33)
				  + (m.M41 * m.M32 * m.M23) + (m.M31 * m.M22 * m.M43) + (m.M21 * m.M42 * m.M33);

				r.M12 = 0
				  - (m.M12 * m.M33 * m.M44) - (m.M32 * m.M43 * m.M14) - (m.M42 * m.M13 * m.M34)
				  + (m.M42 * m.M33 * m.M14) + (m.M32 * m.M13 * m.M44) + (m.M12 * m.M43 * m.M34);
				r.M22 = 0
				  + (m.M11 * m.M33 * m.M44) + (m.M31 * m.M43 * m.M14) + (m.M41 * m.M13 * m.M34)
				  - (m.M41 * m.M33 * m.M14) - (m.M31 * m.M13 * m.M44) - (m.M11 * m.M43 * m.M34);
				r.M32 = 0
				  - (m.M11 * m.M32 * m.M44) - (m.M31 * m.M42 * m.M14) - (m.M41 * m.M12 * m.M34)
				  + (m.M41 * m.M32 * m.M14) + (m.M31 * m.M12 * m.M44) + (m.M11 * m.M42 * m.M34);
				r.M42 = 0
				  + (m.M11 * m.M32 * m.M43) + (m.M31 * m.M42 * m.M13) + (m.M41 * m.M12 * m.M33)
				  - (m.M41 * m.M32 * m.M13) - (m.M31 * m.M12 * m.M43) - (m.M11 * m.M42 * m.M33);

				r.M13 = 0
				  + (m.M12 * m.M23 * m.M44) + (m.M22 * m.M43 * m.M14) + (m.M42 * m.M13 * m.M24)
				  - (m.M42 * m.M23 * m.M14) - (m.M22 * m.M13 * m.M44) - (m.M12 * m.M43 * m.M24);
				r.M23 = 0
				  - (m.M11 * m.M23 * m.M44) - (m.M21 * m.M43 * m.M14) - (m.M41 * m.M13 * m.M24)
				  + (m.M41 * m.M23 * m.M14) + (m.M21 * m.M13 * m.M44) + (m.M11 * m.M43 * m.M24);
				r.M33 = 0
				  + (m.M11 * m.M22 * m.M44) + (m.M21 * m.M42 * m.M14) + (m.M41 * m.M12 * m.M24)
				  - (m.M41 * m.M22 * m.M14) - (m.M21 * m.M12 * m.M44) - (m.M11 * m.M42 * m.M24);
				r.M43 =
				  -(m.M11 * m.M22 * m.M43) - (m.M21 * m.M42 * m.M13) - (m.M41 * m.M12 * m.M23)
				  + (m.M41 * m.M22 * m.M13) + (m.M21 * m.M12 * m.M43) + (m.M11 * m.M42 * m.M23);

				r.M14 = 0
				  - (m.M12 * m.M23 * m.M34) - (m.M22 * m.M33 * m.M14) - (m.M32 * m.M13 * m.M24)
				  + (m.M32 * m.M23 * m.M14) + (m.M22 * m.M13 * m.M34) + (m.M12 * m.M33 * m.M24);
				r.M24 = 0
				  + (m.M11 * m.M23 * m.M34) + (m.M21 * m.M33 * m.M14) + (m.M31 * m.M13 * m.M24)
				  - (m.M31 * m.M23 * m.M14) - (m.M21 * m.M13 * m.M34) - (m.M11 * m.M33 * m.M24);
				r.M34 = 0
				  - (m.M11 * m.M22 * m.M34) - (m.M21 * m.M32 * m.M14) - (m.M31 * m.M12 * m.M24)
				  + (m.M31 * m.M22 * m.M14) + (m.M21 * m.M12 * m.M34) + (m.M11 * m.M32 * m.M24);
				r.M44 = 0
				  + (m.M11 * m.M22 * m.M33) + (m.M21 * m.M32 * m.M13) + (m.M31 * m.M12 * m.M23)
				  - (m.M31 * m.M22 * m.M13) - (m.M21 * m.M12 * m.M33) - (m.M11 * m.M32 * m.M23);

				return r;
			}

			MatrixD mrot(Vector3D a, double ang)
			{
				var r = new MatrixD();
				double s = Math.Sin(ang);
				double c = Math.Cos(ang);
				var x = a.X; var y = a.Y; var z = a.Z;
				r.M11 = 1 + (1 - c) * (x * x - 1);
				r.M12 = -z * s + (1 - c) * x * y;
				r.M13 = y * s + (1 - c) * x * z;
				r.M21 = z * s + (1 - c) * x * y;
				r.M22 = 1 + (1 - c) * (y * y - 1);
				r.M23 = -x * s + (1 - c) * y * z;
				r.M31 = -y * s + (1 - c) * x * z;
				r.M32 = x * s + (1 - c) * y * z;
				r.M33 = 1 + (1 - c) * (z * z - 1);
				r.M41 = r.M42 = r.M43 = 0;
				r.M44 = 1;
				return r;
			}

			MatrixD mtran(Vector3D v)
			{
				var r = MatrixD.Identity;
				r.M41 = v.X;
				r.M42 = v.Y;
				r.M43 = v.Z;
				return r;
			}

			MatrixD mscale(Vector3D v)
			{
				var r = MatrixD.Identity;
				r.M11 = v.X;
				r.M22 = v.Y;
				r.M33 = v.Z;
				return r;
			}

			#endregion //Matrix Math

			Var vBoundingSphere(BoundingSphereD s)
			{
				Var r = th.mkv('a');
				r["Center"] = vVec(s.Center);
				r["Radius"] = s.Radius;
				// TODO: Utility methods
				return r;
			}


			// TODO: Make system variables for utility calls like length and such
			public Vector3D v2vec(Var v)
			{
				return (v.d == null) ? new Vector3D() : new Vector3D(v.d["X"], v.d["Y"], v.d["Z"]);
			}
			Vector3I v2vec3i(Var v)
			{
				return (v.d == null) ? new Vector3I() : new Vector3I(v.d["X"], v.d["Y"], v.d["Z"]);
			}
			Var vVec3i(Vector3I v)
			{
				Var r = th.mkv('a');
				r.d["X"] = v.X;
				r.d["Y"] = v.Y;
				r.d["Z"] = v.Z;
				return r;
			}

			#endregion //Geometry


			E v2e<E>(Var val) // Var (string) to enum
			{
				//MyAssemblerMode m = MyAssemblerMode.Assembly;
				//foreach (var x in Enum.GetValues(typeof(MyAssemblerMode)))
				string vs = val.str;
				foreach (var x in Enum.GetValues(typeof(E)))
				{
					if (vs == x.ToString()) { return (E)x; }
				}
				throw new InvalidCastException();
			}


















			string ISystem.GetSource(string sourceName)
			{
				var block = m_prg.GridTerminalSystem.GetBlockWithName(sourceName);
				if (block == null) return "";
				return block.CustomData;
			}

			//static MyGridProgram prg(Var sys_var)
			//{
			//	return (sys_var.sy.cx as BSGridSystem).m_prg;
			//}
			//static BSGridSystem thisv(Var v) { return v.sy.cx as BSGridSystem; }
			//static void print_v(Var fnv)
			//{
			//	var pthis = thisv(fnv);
			//	var con = pthis.console;
			//	if (con == null) return;
			//	print(con, )
			//}


			//public void print_v(Var fnv)
			//{
			//	//var pthis = thisv(fnv);
			//	var pthis = (fnv.sy.cx as BSGridSystem);
			//	if (pthis == null) return;
			//	var con = pthis.console;
			//	if (con == null) return;
			//	Thread th = fnv.th;
			//	if (th == null) return;
			//	Var v;
			//	string ln = "";
			//	int safety = 0;
			//	while (true)
			//	{
			//		v = th.popv();
			//		if (!Object.ReferenceEquals(v, null) && v.ty == 'u') break;
			//		safety++;
			//		if (safety >= MaxFunctionCallParams) return;
			//		ln += v.str;
			//	} // while (v.ty != 'u');
			//	var L = false;
			//	#region print() to LCD
			//	L = true;
			//	#endregion
			//	if (L)
			//	{
			//		#region print() to LCD
			//		print(con, ln);
			//		#endregion
			//	}
			//	else m_prg.Echo(ln);
			//}
			#region print() to LCD
			//public static float CharWidth(IMyTextPanel p)
			//{
			//	string sz = $"{p.SurfaceSize.X}x{(int)p.SurfaceSize.Y}";
			//	switch (sz)
			//	{
			//		case "512x128": return (int)(100 / p.FontSize);
			//		case "512x512": return (int)(25 / p.FontSize);
			//		case "1024x512": return (int)(50 / p.FontSize);
			//		case "512x307": return (int)(25 / p.FontSize);
			//	}
			//	if (p.SurfaceSize.X >= p.SurfaceSize.Y * 2) return 50;
			//	return 25;
			//}
			public static float CharsHigh(IMyTextPanel p) => p.SurfaceSize.Y < 512 ? 10 / p.FontSize : 17 / p.FontSize ;
			//public static float CharHeight(IMyTextPanel p)
			//{
				// TODO: test
				//string sz = $"{p.SurfaceSize.X}x{(int)p.SurfaceSize.Y}";
				//string sz = $"{p.TextureSize.X}x{(int)p.TextureSize.Y}";
				//switch (sz)
				//{
				//	case "512x128": return (int)(8 / p.FontSize);
				//	case "512x512": return (int)(16 / p.FontSize);
				//	case "1024x512": return (int)(16 / p.FontSize);
				//	case "512x307": return (int)(10 / p.FontSize);
				//}
				//return (int)(16 / p.FontSize);
				
			//}

			//public static List<string> MyAllocLns()
			//{
			//	if (g_prg != null) g_prg.Echo("Allocating new lns");
			//	return new List<string>();
			//}
			////static readonly string[] nla = { "\r" }; // { Environment.NewLine };
			//public List<string> lns = new List<string>(); // Print buffer
			public string prb = "";
			public void print(IMyTextPanel con, string ln)
			{
				//var dbg = g_prg.GridTerminalSystem.GetBlockWithName("BSS-Debug") as IMyTextPanel;
				//if (dbg != null)
				//{
				//	dbg.WriteText("printing: ", true);
				//	dbg.WriteText(ln, true);
				//	dbg.WriteText("\n", true);
				//}

				//m_prg.Echo(ln);
				//con.WriteText(ln, true);
				//return;
				var tb4 = prb; //con.GetText();
				//if (tb4.Length == 2)
				//{
				//	m_prg.Echo($"chars are {(int)tb4[0]}, {(int)tb4[1]}");
				//}
				//m_prg.Echo($"Before: {tb4.Length} chars in print buffer");
				//m_prg.Echo($"{tb4.Count((char c) => c == '\n')} lines by count()");
				List<string> lns = new List<string>(tb4.Replace("\r", "").Split('\n'));
				//List<string> lns = new List<string>(tb4.Split('\n'));
				
				
				//for (int i = 0; i < lns.Count; i++) lns[i] = lns[i].Replace("\r", "");
				
				
				//m_prg.Echo($"Before: {lns.Count} lines");
				var n = new StringBuilder();
				var bl = new StringBuilder((lns.Count > 0) ? lns.Last() : "");
				//if (bl.Length > 0)
				{
					if (lns.Count > 0) lns.RemoveAt(lns.Count - 1);
				}
				//m_prg.Echo($"prev last ln {bl.Length} chars");
				var M1 = con.MeasureStringInPixels(bl, con.Font, con.FontSize * F2SX);
				float cw = M1.X;
				float nw;
				//m_prg.Echo($"ln.Length = {ln.Length}");
				for (int i = 0; i < ln.Length; i++)
				{
					n.Clear();
					n.Append(ln[i]);
					nw = con.MeasureStringInPixels(n, con.Font, con.FontSize * F2SX).X;
					//con.TextureSize
					//con.SurfaceSize
					if (ln[i] == '\n') { cw = 0; nw = 0; }
					if (cw+nw > con.SurfaceSize.X) // SurfaceSize is the actual display size, TextureSize is just the power of 2 greater than that.
					{
						//m_prg.Echo($"Flushing {bl.Length} chars");
						lns.Add(bl.ToString());
						bl.Clear();
						cw = nw;
					}
					else
					{
						cw += nw;
					}
					bl.Append(n);
					//n.Remove(0, 1);
				}


				//if (bl.Length > 0)
				//{
				//	if (lns.Count > 0) lns.RemoveAt(lns.Count - 1);
				//	lns.Add(bl.ToString());
				//}
				//m_prg.Echo($"Adding current {bl.Length} char line");
				lns.Add(bl.ToString());
				//m_prg.Echo($"lns.Count = {lns.Count} ");


				//int lac = lns.Count - (int)(con.SurfaceSize.Y / (M1.Y * F2SX)) + 1; // TODO: TextureSize or SurfaceSize?
				//int lac = lns.Count - (int)(con.SurfaceSize.Y / (CharHeight(con) * F2SY)) + 1; // TODO: TextureSize or SurfaceSize?
				int lac = lns.Count - (int)CharsHigh(con);
				//m_prg.Echo($"lns {lns.Count} - Surf {con.SurfaceSize.Y * F2SY} / (M1.Y {M1.Y} * f2s {F2SX}) + 1 = {lac}");
				if (lac > 0)
				{
					//m_prg.Echo($"Scrolling {lac} lines off top");
					lns.RemoveRange(0, lac);
				}
				//m_prg.Echo($"After: {lns.Count} lines");
				//string f = String.Join("\r\n", lns.ToArray());
				prb = String.Join("\r\n", lns.ToArray());
				//f = f.Substring(1, f.Length - 2);
				con.WriteText(prb, false);
				//con.WriteText("\n", true);
				//m_prg.Echo($"lns.Count = {lns.Count} after final output");
				//m_prg.Echo("Before:");
				//m_prg.Echo(tb4);
				return;


				//ln.Count((char c)=>c=='\n');
				//con.MeasureStringInPixels(ln, con.Font, con.FontSize);










				//// TODO:
				//// - If ln contains newlines, reset horizontal position
				//// - var  sb = new StringBuilder(stuff);
				////   lcd.MeasureStringInPixels(sb, lcd.Font, 1)
				////con.WriteText(ln, true);
				////return;
				//if (ln.Length == 0) return;
				////bool isLastNewLine = ln.Length > 0 && "\r\n".Contains(ln[ln.Length - 1]);
				//int cw = CharWidth(con);
				//int ch = CharHeight(con);
				////const StringSplitOptions op = StringSplitOptions.None;
				////List<string> lns = new List<string>(con.GetText().Split(nla, op)); //'\n'); );
				//string b4 = con.GetText();
				//string aft = b4;
				////List<string> lns = new List<string>(b4.Split('\n'));
				//if (lns.Count == 0) { con.WriteText(ln); return; }
				//int oldLineCount = lns.Count;
				//int firstRem = cw - lns[lns.Count - 1].Length;
				//if (ln.Length > firstRem)
				//{
				//	aft += ln.Substring(0, firstRem) + "\n";
				//	ln = ln.Substring(firstRem);
				//}
				//while (ln.Length > cw)
				//{
				//	aft += ln.Substring(0, cw) + "\n";
				//	ln = ln.Substring(cw);
				//}
				//if (ln.Length > 0) aft += ln;
				//lns = new List<string>(aft.Split('\n'));
				//if (lns.Count > ch) lns.RemoveRange(0, Math.Min(lns.Count - ch, oldLineCount));
				//string final = "";
				//for (int iln = 0; iln < lns.Count; iln++)
				//{
				//	string fln = lns[iln];
				//	string fln2 = "";
				//	if (fln.Length > 0 && "\r\n".Contains(fln[fln.Length - 1])) fln2 = fln.Substring(0, fln.Length - 1);
				//	else fln2 = fln;
				//	if (fln2.Length > 0 && "\r\n".Contains(fln2[0])) fln2 = fln2.Substring(1);
				//	final += fln2;
				//	if (iln < lns.Count - 1) final += "\n";
				//	//con.WriteText(fln2, true);
				//	//con.WriteText(fln2 + "\n", true);
				//	//final += fln + '\n' + Environment.NewLine; // (i > 0 ? Environment.NewLine : "") + fln;
				//	//iln++;
				//}
				//con.WriteText(final);
				//
				//
				//
				//
				//
				//
				//
				//////if (lns.Count > 0 && lns[lns.Count - 1].Length == 0) { lns.RemoveAt(lns.Count - 1); }
				////while (ln.Length > cw)
				////{
				////	lns.Add(ln.Substring(0, cw));
				////	ln = ln.Substring(cw);
				////}
				////if (ln.Length > 0) lns.Add(ln);
				////
				////
				////
				////while (lns.Count > ch && lns.Count > 1) lns.RemoveAt(0);
				////string final = "";
				////int i = 0;
				//////con.WriteText($"lns.Count={lns.Count}\n", false);
				//////con.WriteText("", false);
				////string fln;
				//////foreach (var fln in lns)
				////for (int iln = 0; iln < lns.Count; iln++)
				////{
				////	fln = lns[iln];
				////	string fln2 = "";
				////	if (fln.Length > 0 && "\r\n".Contains(fln[fln.Length - 1])) fln2 = fln.Substring(0, fln.Length - 1);
				////	else fln2 = fln;
				////	if (fln2.Length > 0 && "\r\n".Contains(fln2[0])) fln2 = fln2.Substring(1);
				////	final += fln2;
				////	//if (iln < lns.Count - 1) final += "\n";
				////	//con.WriteText(fln2, true);
				////	//con.WriteText(fln2 + "\n", true);
				////	//final += fln + '\n' + Environment.NewLine; // (i > 0 ? Environment.NewLine : "") + fln;
				////	i++;
				////}
				//////if (isLastNewLine) final += "\n";
				////con.WriteText(final);
				//////con.WriteText(final, true);
			}
			#endregion // print() to LCD

		} // END class BSGridSystem

		class InitSys : BSGridSystem // The init script environment
		{
			public InitSys(MyGridProgram p_prg, IMyTextPanel con, List<PWatch> pw)
				: base(p_prg, con, pw) { }

			public override void MyInitScope(Thread th_p, Dictionary<string, Var> sc)
			{
				th = th_p;
				base.MyInitScope(th, sc);

				sc["print"] = SysVar.mkfn(th, "print", this, (object cx, List<Var> a) =>
				{
					var sys = cx as InitSys;
					string ln = "";
					//Var v;
					//do
					//{
					//	v = fnv.th.popv();
					//	if (v.ty == 'u') break;
					//	ln += v.str;
					//} while (v.ty != 'u');
					foreach (Var arg in a)
					{
						ln += arg.str;
					}
					m_prg.Echo(ln);
					return null;
				});

				//sc["onSave"] = SysVar.mkFunction(th, "onSave")
			}

		}






















































































































































































































		class Thread
		{
			//struct stel // stack element
			//{
			//	public Token tk;
			//	public int i;
			//	string ls;
			//	string rs;
			//	double ln;
			//	double rn;
			//};

			//public Tokenizer tz; // = new Tokenizer();
			public bool showInternalErrs = false;
			public List<tsel> ts = new List<tsel>(); // token stack - need random access for variable search
			public List<Scope> ss = new List<Scope>();

			static void md<K, V>(Dictionary<K, V> dest, Dictionary<K, V> src, bool overwrite) // merge dictionary
			{
				if (dest == null || src == null) return;
				foreach (var el in src)
				{
					bool ck = dest.ContainsKey(el.Key);
					if ((!ck) || (ck && overwrite)) dest[el.Key] = el.Value;
				}
			}


			public void Load(string src, string srcName, ISystem p_sys, Scheduler sch_p)
			{
				//tz = new Tokenizer();
				tzs.Clear();
				ts.Clear();
				vs.Clear();
				tzs.Push(new Tokenizer());
				sys = p_sys;
				tst = State.LOAD;
				sourceName = srcName;
				tz.sourceName = srcName;
				tz.LoadStart(src, srcName);
				sch = sch_p;
			}

			//Stack<Var> iv = new Stack<Var>(); 
			Stack<vsel> vs = new Stack<vsel>(); // internal var stack - used for phase progression of statements and loops
												// These are basically the rvalues generated by an expression
												// Could be an lvalue as well tho

			public int VarStackDepth { get { return vs.Count; } }
			public int TokenStackDepth { get { return ts.Count; } }
			public string sourceName;

			public enum State
			{
				LOAD,
				RUN,
				WAIT,
				SUSP,
				TERM,
				ERR
			};
			public State tst; // Thread state
			public State pst = State.LOAD; // previous state (if suspended)
			public Exception err = null;
			public State Status { get { return tst; } set { pst = tst; tst = value; } }
			public Scheduler sch = null;

			public class Watch
			{
				//public Var v; // v maintains a reference to the original var
				public Ref v; // v maintains a reference to the original var
				public Var prev; // = new Var(); // prev is a copy by value, assign() on change/init
				private static int nextId = 1;
				public int id = nextId++;
				public Token t; // '{' block to execute
				public Dictionary<string, Var> sc = new Dictionary<string, Var>(); // scope
			}
			public Dictionary<int, Watch> watches = new Dictionary<int, Watch>();

			//public long sleepUntil = 0;
			public DateTime wakeTime = new DateTime();
			public bool sleeping = false;

			Stack<Tokenizer> tzs = new Stack<Tokenizer>();
			public Tokenizer tz { get { return (tzs.Count > 0) ? tzs.Peek() : null; } }


			public Thread() { tst = State.TERM; }

			public ISystem sys;
			public Thread(string sourceCode, string srcName, ISystem p_sys, Scheduler sch_p)
			{
				sys = p_sys;
				Load(sourceCode, srcName, p_sys, sch_p);
			}
			//Token top {get { return stack.Last().tk; } }
			void exn(string msg) { throw new Exception(msg); }

			public void Restart()
			{
				if (tst == State.LOAD) return;
				ts.Clear();
				vs.Clear();
				while (tzs.Count > 1) { tzs.Pop(); }
				if (tzs.Count > 0) sourceName = tz.sourceName;
				StartRun();
			}

			void StartRun()
			{
				//cu = new stel { tk = top, i = 0 };
				if (tst == State.LOAD) return;

				//ts.Clear();
				//vs.Clear();
				//while (tzs.Count > 1) { tzs.Pop(); }

				//var ptst = ts.Last(); // previous token stack top
				ts.Clear();
				pusht(tz.top);
				ts[0].iso = true;
				ts[0].ssc = 1; // There will be a scope for the top level

				ss.Clear();
				pushs(tz.top); // new Dictionary<string, Var>();
				ss[0].iso = true;

				//ts.Last().sc.iso = true;
				//sys.InitScope(this, ts[0].sc.v);
				var sc = new Dictionary<string, Var>();
				ss[0].v = sc;
				Builtins(sc);
				sys.InitScope(this, sc);
				//rs.Push(new rsel(top));
				tst = State.RUN;
			}
			void Builtins(Dictionary<string, Var> sc)
			{
				// TODO: Let SysVar have a way to make "native" funcs that know how to popv(), to avoid "new List" all the time
				sc["keys"] = SysVar.mkfn(this, "keys", this, (object x, List<Var> a) =>
				{
					var r = mkv('a');
					int i = 0;
					if (a[0].sy != null)
					{
						foreach (var k in a[0].sy.props.Keys) r[i++] = k;
						foreach (var k in a[0].sy.methods.Keys) r[i++] = k;
					}
					else
					{
						if (a.Count == 0 || a[0].d == null || a[0].d.Count == 0) return null;
						foreach (var k in a[0].d.Keys) r[i++] = k;
					}
					return r;
				});
				sc["keycount"] = SysVar.mkfn(this, "keycount", this, (object x, List<Var> a) => a[0].d?.Count);
				sc["len"] = SysVar.mkfn(this, "len", this, (object x, List<Var> a) =>
				{
					switch (a[0].ty)
					{
						case 's': return a[0].s.Length;
						case 'a': return a[0].a.Count;
					}
					return 0;
				});
				sc["str"] = SysVar.mkfn(this, "str", this, (object x, List<Var> a) => a[0].str);
				sc["chr"] = SysVar.mkfn(this, "chr", this, (object x, List<Var> a) => Convert.ToChar((int)a[0].num).ToString());
				sc["codepoint"] = SysVar.mkfn(this, "codepoint", this, (object x, List<Var> a) => Convert.ToInt32(a[0].str[0]));
				sc["round"] = SysVar.mkfn(this, "round", this, (object x, List<Var> a) => Math.Round(a[0].num, (int)(a.Count > 1 ? a[1].num : 0.0)));
				sc["floor"] = SysVar.mkfn(this, "floor", this, (object x, List<Var> a) => Math.Floor(a[0].num));
				sc["ceil"] = SysVar.mkfn(this, "ceil", this, (object x, List<Var> a) => Math.Ceiling(a[0].num));
				sc["substr"] = SysVar.mkfn(this, "substr", this, (object x, List<Var> a) =>
				{
					if (a.Count > 2) return a[0].str.Substring(a[1], a[2]);
					else return a[0].str.Substring(a[1]);
				});
				sc["find"] = SysVar.mkfn(this, "find", this, (object x, List<Var> a) => a[0].str.IndexOf(a[1], (a.Count > 2 ? (int)a[2] : 0)));

				#region Geometry
				sc["sin"] = SysVar.mkfn(this, "sin", this, (object x, List<Var> a) => Math.Sin(a[0].num));
				sc["cos"] = SysVar.mkfn(this, "cos", this, (object x, List<Var> a) => Math.Cos(a[0].num));
				sc["tan"] = SysVar.mkfn(this, "tan", this, (object x, List<Var> a) => Math.Tan(a[0].num));
				sc["asin"] = SysVar.mkfn(this, "asin", this, (object x, List<Var> a) => Math.Asin(a[0].num));
				sc["acos"] = SysVar.mkfn(this, "acos", this, (object x, List<Var> a) => Math.Acos(a[0].num));
				sc["atan"] = SysVar.mkfn(this, "atan", this, (object x, List<Var> a) => Math.Atan(a[0].num));
				sc["sinh"] = SysVar.mkfn(this, "sinh", this, (object x, List<Var> a) => Math.Sinh(a[0].num));
				sc["cosh"] = SysVar.mkfn(this, "cosh", this, (object x, List<Var> a) => Math.Cosh(a[0].num));
				sc["tanh"] = SysVar.mkfn(this, "tanh", this, (object x, List<Var> a) => Math.Tanh(a[0].num));
				sc["sqrt"] = SysVar.mkfn(this, "sqrt", this, (object x, List<Var> a) => Math.Sqrt(a[0].num));
				#endregion
			}

			void ex(string msg, Token tk) { throw new Exception($"{msg} at line {tk.ln} ch {tk.ch}"); }
			void ex(string msg)
			{
				//ex(msg, ts.Last().t.sub[ts.Last().i]);
				Token t = null, tp; // token, token parent
				if (ts.Count > 0)
				{
					tp = ts.Last().t;
					if (tp.sub.Count > ts.Last().i)
					{
						t = tp.sub[ts.Last().i];
					}
				}
				ex(msg, t);
			}

			public void pushv(Ref vp)
			{
				if (vp != null && vp.v != null)
				{
					vp.v.th = this;
					if (vp.v.sy != null) vp.v.sy.read(vp);
				}
				vsel el = new vsel { rv = vp, };
				vs.Push(el);
			}
			public Ref popv()
			{
				if (vs.Count > ts.Last().vsc)
				{
					//return vs.Pop().v;
					return vs.Pop().rv;
				}
				return mkv(); //new Var('0');
			}


			public Ref fv(string name, bool p_throw = false) // find variable
			{
				if (name == "null") return mkv('0');
				//tsel el = fvscel(name, p_throw);
				var sc = fvsc(name);
				if (sc == null)
				{
					Var retFn = ffn(name);
					if (isnr(retFn)) return null;
					return new Ref(retFn);
				}
				//if (el == null) return null;
				if (sc == null) return null;
				//return el.sc[name];
				//return new Ref(el.sc, name);
				var ret = new Ref(sc.v, name);
				ret.v.sc = (ss.Count > 0 ? ss.Last() : null);
				return ret;
			}
			//tsel fvscel(string name, bool p_throw = false) // Find variable scope element
			//{
			//	for (int i = ts.Count - 1; i >= 0; i--)
			//	{
			//		if ((ts[i].sc != null) && (ts[i].sc.ContainsKey(name))) return ts[i];
			//		if (ts[i].iso) break;
			//	}
			//	if (p_throw) ex($"Variable not found: '{name}'");
			//	return null;
			//}
			Scope fvsc(string name, bool p_throw = false) // find variable scope
			{
				if (ss.Count == 0) { return null; }
				Scope s = ss.Last();
				do
				{
					if (s.v != null && s.v.ContainsKey(name)) { return s; }
					if (s.iso) { break; }
					s = s.p;
				} while (s != null);
				//for (int i = ss.Count - 1; i >= 0; i--)
				//{
				//	if (ss[i]?.v != null && ss[i].v.ContainsKey(name)) { return ss[i]; }
				//	if (ss[i].iso) { break; }
				//}
				if (p_throw) ex($"Variable not found: '{name}'");
				return null;
			}
			Var ffn(string name) // find function
			{
				Token t = ts[ts.Count - 1].t;
				while (t != null)
				{
					if (t.fns != null)
					{
						if (t.fns.ContainsKey(name))
						{
							Var f = mkv('u', t.fns[name].con); // new Var('u');
															   //f.name = t.fns[name].con;
							f.t = t.fns[name];
							f.sc = (ss.Count > 0 ? ss.Last() : null);
							return f;
						}
					}
					t = t.p;
					//if (!t.p.TryGetTarget(out t)) break; // ex("Token life cycle error");
				}
				return null;
			}

			public void pusht(Token t, int i = 0)
			{
				tsel s = new tsel(t);
				s.i = i;
				s.vsc = vs.Count;
				s.ssc = ss.Count;
				ts.Add(s); //new rsel(t));
			}
			public void popt()
			{
				if (ts.Count == 0) { exn("Stack underflow"); }
				//if (iv.Count != rs.Last().ivc + 1) ex("Internal stack error."); // not always, e.g. blank tokens dont push any vars

				// Make sure the scope stack is synchronized with the token stack.
				// With the var stack (vs) you have things like return values and expression evaluations
				// that need to carry between tokens, but the scope from a sub token should
				// never propagate to its parent.

				ends();
				ts.RemoveAt(ts.Count - 1);
			}

			public Scope pushs(Token t = null)
			{
				ss.Add(new Scope(t, (ss.Count > 0 ? ss.Last() : null)));
				var sc = ss.Last();
				//for (int i = ts.Count - 1; i >= 0; i--)
				//{
				//	// TODO: This might be a problem for recursive functions
				//	if (ts[i].t == t)
				//	{
				//		ts[i].sc = sc;
				//		break;
				//	}
				//}
				return sc;
			}
			public Scope pops()
			{
				var c = ts.Last().ssc;
				if (vs.Count > c)
				{
					ss.RemoveAt(ss.Count - 1);
				}
				//if (ss.Count == 0) { ex("stack underflow (scope)"); }
				return (ss.Count >= c ? ss.Last() : null);
			}

			// Find Scope - the narrowest (most local) scope where variables should be searched.
			// A {} can be a scope if its parent token is not a conditional
			//tsel fsc()
			//{
			//	return ts[fsci()];
			//}
			//int fsci(int start)
			//{
			//	for (int i = start; i > 0; i--)
			//	{
			//		if ("fwduI".Contains(ts[i].t.ty)) return i;
			//		if (ts[i].t.ty == '{')
			//		{
			//			if (!"icefwdsuI".Contains(ts[i - 1].t.ty)) return i;
			//		}
			//	}
			//	return 0;
			//}

			//int fsci()
			//{
			//	return fsci(ts.Count - 1);
			//}
			//Var decl(string name) // declare variable
			//Ref decl(string name) // declare variable
			//{
			//	Var v = mkv('0', name);
			//	tsel el = fsc(); // anc("wfd{T", true);
			//	if (el.sc == null) el.sc = new Dictionary<string, Var>();
			//	//Ref r = el.sc[name]
			//	el.sc[name] = v;
			//	Ref r = new Ref(el.sc, name);
			//	r.v = v; // just in case, could check reference for debugging but eh
			//	return r;
			//}
			Ref decl(string name)
			{
				Var v = mkv('0', name);
				ss.Last().v[name] = v;
				return new Ref(ss.Last().v, name);
			}
			public Var mkv(char ty = '0', string name = "*temp") // make variable (new object) - populates thread member
			{
				Var v = new Var(this, ty);
				v.name = name;
				return v;
			}

			bool isnr(object o) { return Object.ReferenceEquals(o, null); } // Is null
			public void begv() { ts.Last().vsc = vs.Count; }
			public void endv()
			{
				////if (rs.Last().ivc != iv.Count) ex("Internal stack error");
				int c = ts.Last().vsc;
				while (vs.Count > c)
				{
					vs.Pop();
					//ex("Too many expressions in statement");
				}
				if (vs.Count < c) ex("Var stack corrupted, too many pops.", ts.Last().t);
			}
			public void ends() // Pops scope to beginning of token phase 0
			{
				int c = ts.Last().ssc;
				while (ss.Count > c) { ss.RemoveAt(ss.Count - 1); }
				if (ss.Count < c) ex("Scope stack corrupted, too many pops.");
			}

			public Var ReturnValue
			{
				get
				{
					if (tst == State.TERM && vs.Count > 0) return vs.First().rv.v;
					return mkv('0'); //new Var('0');
				}
			}

			static Int64 bt(double n) { return ((Int64)n) & 0x000FFFFFFFFFFFFF; }
			public void step()
			{
				//if (isnr(this)) { Debug.WriteLine("Thread 'this' is null"); }
				switch (tst)
				{
					case State.LOAD:
						if (tzs.Count == 0)
						{
							err = new Exception("Tokenizer stack is empty.");
							Status = State.ERR;
							return;
						}
						if (!tz.LoadContinue())
						{
							switch (tz.Status)
							{
								case Tokenizer.State.ERR:
									tst = State.ERR;
									err = tz.err;
									break;
								case Tokenizer.State.READY:
									//push(tz.top);
									tst = State.RUN;
									StartRun();
									break;
								default:
									tst = State.ERR;
									err = new Exception("Parser in an undefined state");
									break;
							}
						}
						break;
					case State.RUN:
						try
						{
							stepIn();
						}
						catch (Exception e)
						{
							//if (rs.Count > 0) throw new Exception($"{t.ln}:{t.ch} {e.Message}");
							////else msg = e.Message
							//else throw;
							if (ts.Count > 0)
							{
								Token t = ts.Last().t;
								string msg = $"{t.ln},{t.ch} {tz.sourceName}: {e.Message}";
								if (showInternalErrs) msg += $"\r\n(internal info)\r\n{e.StackTrace}";
								//err = new Exception($"{t.ln},{t.ch} {tz.sourceName}: {e.Message}{showInternalErrs ? \r\n(internal info)\r\n{e.StackTrace}", e);
								err = new Exception(msg, e);
							}
							else err = e;
							tst = State.ERR;
						}
						break;
				}
			}
			public void stepIn()
			{
				var st = ts.Last();
				Token t = st.t;
				if (st.i < 0) { st.i = 0; }
				int i = st.i;
				//int ivc = iv.Count();
				int cn = t.sub.Count;
				int ph = st.ph;
				Token si = (i < cn) ? t.sub[i] : null;
				Token psi = (i > 0 && i <= cn) ? t.sub[i - 1] : null;
				Token si1 = (i < cn - 1) ? t.sub[i + 1] : null;
				//if (st.ph > 0 && i >= cn) goto breakStep;
				if (i >= cn) goto stepOut;
				Ref lref, rref;
				Ref rv = null; // reference variable - used for temporary value to stack
				Var l, r;// v = null;
						 //Token an; // ancestor
				tsel el;
				//#if DEBUG
				//			List<Var> ivdbg = new List<Var>();
				//			foreach (var ivi in vs)
				//			{
				//				ivdbg.Add(ivi.v);
				//			}
				//#endif
				switch (si.ty)
				{
					case 'T':
						ex("Top should not be a sub element");
						goto nxi;
					case '{':
						// TODO: Could clean this up, just pusht, pushs, nxi
						switch (st.ph)
						{
							case 0:
								pusht(si);
								pushs(si);
								goto nxp;
							case 1:
								pops();
								goto nxi;
						}
						break;
					case ';':
						//rs.Push(new rsel(si));
						//bool infn = "u".Contains(t.ty) || (t.p != null && "u".Contains(t.p.ty));
						if (si.sub.Count == 0 && vs.Peek().rv != null && vs.Peek().rv.v != null && vs.Peek().rv.v.ty == 'u')
						{
							//!TEST disabling this
							vs.Pop();
							goto nxi;
						}
						switch (ph)
						{
							case 0:
								//st.ivc = iv.Count();
								//if (!infn) ivcBeg();
								begv();
								pusht(si);
								goto nxp;
							case 1:
								//ivpop();
								//if (st.ivc != iv.Count) ex("Internal stack error");
								//if (!infn) ivcEnd();

								endv();
								//while (vs.Count > ts.Last().vsc) { popv(); }
								goto nxi;
						}
						break;
					case '-':
						Token tkl = null, tkr = null;
						if (si.sub.Count >= 1 && si.sub[0].ty == 'l') tkl = si.sub[0];
						if (si.sub.Count >= 2 && si.sub[1].ty == 'r') tkr = si.sub[1];
						if (tkl == null || tkr == null) ex($"Operator '{si.con}' missing left/right pair", si);
						switch (ph)
						{
							case 0:
								begv(); // st.ivc = iv.Count();
										//push(tkr);
								pusht(tkl);
								goto nxp;
							case 1:
								//push(tkl);
								// conditional evaluation for boolean and/or, returns one of the actual values not just a boolean
								if (si.con == "&&" || si.con == "and")
								{
									l = popv();
									if (!l.tr) pushv(l);
									else pusht(tkr);
									goto nxi;
								}
								else if (si.con == "||" || si.con == "or")
								{
									l = popv();
									if (l.tr) pushv(l);
									else pusht(tkr);
									goto nxi;
								}
								pusht(tkr);
								goto nxp;
							case 2:
								//if (si.con == "&&" || si.con == "and" || si.con == "||" || si.con == "or") goto nxi; // already handled
								//l = ivpop();
								//r = ivpop();

								//r = popv();
								//l = popv();
								rref = popv();
								lref = popv();
								l = lref.v;
								r = rref.v;
								endv();
								switch (si.con)
								{
									case "+":
										rv = l + r;
										break;
									case "-":
										rv = l - r;
										break;
									case "*":
										rv = l * r;
										break;
									case "/":
										rv = l / r;
										break;
									case "%":
									case "mod":
										rv = l.num % r.num;
										break;
									case "%=":
										l.assign(l.num % r.num);
										rv = l;
										break;
									case "==":
										if (l.cmp(r) == 0) rv = 1;
										else rv = 0;
										break;
									case "!=":
									case "<>":
										if (l.cmp(r) == 0) rv = 0;
										else rv = 1;
										break;
									case "&&":
									case "and":
										ex("Interpreter bug, || past end phase", si);
										//if (l.tr && r.tr) v = 1;
										//else v = 0;
										rv = null; // just so it's initialized with a value
										break;
									case "||":
									case "or":
										ex("Interpreter bug, && past end phase", si);
										//if (l.tr || r.tr) v = 1;
										//else v = 0;
										rv = null;
										break;
									case "^^":
									case "xor":
										rv = (l.tr != r.tr);
										break;
									case "@=":
										//sr(); asdfgadfgfdgf
										//l = Var.byRef(r);

										//l.setRef(r);
										lref.AssignRef(rref); //  anghdfjkhgajdfhgjkahdfnjk
															  //lref.xr = true;
										rv = lref;
										break;
									case "=":
										//l.assign(r);
										//if (l.ty == 'r') lref.assign(rref);
										//if ((lref.k != null && lref.sc != null) || l.ty == 'r') { lref.assign(rref); }
										//else l.assign(r);
										// TODO: Put xr check in Ref? eh, I guess it's fine, this is about the only place it happens
										if (rref.xr) lref.AssignRef(rref);
										else lref.AssignValue(rref);
										// TODO: a.b.c = something; lv should know how to call b's assignIndex(c, rv)
										rv = lref; // new Var(r); // TODO: v = r? by ref?
										break;
									case "+=":
										l.assign(l + r);
										rv = l; // new Var(l);
										break;
									case "-=":
										l.assign(l - r);
										rv = l; // new Var(l);
										break;
									case "*=":
										l.assign(l * r);
										rv = l; // new Var(l);
										break;
									case "/=":
										l.assign(l / r);
										rv = l; // new Var(l);
										break;
									case "<":
										if (l.cmp(r) < 0) rv = 1;
										else rv = 0;
										break;
									case "<=":
										if (l.cmp(r) <= 0) rv = 1;
										else rv = 0;
										break;
									case ">":
										if (l.cmp(r) > 0) rv = 1;
										else rv = 0;
										break;
									case ">=":
										if (l.cmp(r) >= 0) rv = 1;
										else rv = 0;
										break;
									case "&":
										// TODO: Test
										rv = ((UInt64)((UInt64)l.num & (UInt64)r.num));// & 0x000FFFFFFFFFFFFF);
										break;
									case "|":
										rv = (UInt64)((Int64)l.num | (Int64)r.num);// & 0x000FFFFFFFFFFFFF;
										break;
									case "^":
										//v = (UInt32)((Int32)l.num ^ (Int32)r.num);
										rv = Math.Pow(l.num, r.num);
										break;
									case "^=":
										l.assign(Math.Pow(l.num, r.num));
										rv = l;
										break;
									case "+^":
										rv = bt(l.num) ^ bt(r.num);
										break;
									case "+^=":
										l.assign(bt(l.num) ^ bt(r.num));
										rv = l;
										break;
									case "<<":
										rv = bt(bt(l.num) << (int)(r.num));
										break;
									case ">>":
										rv = bt(bt(l.num) >> (int)(r.num));
										break;
									case "<<=":
										l.assign(bt(bt(l.num) << (int)(r.num)));
										rv = l;
										break;
									case ">>=":
										l.assign(bt(bt(l.num) >> (int)(r.num)));
										rv = l;
										break;
									case "!":
									case "not":
										if (r.tr) rv = 0;
										else rv = 1;
										break;
									case "~":
										rv = (UInt32)(~((UInt32)r.num));
										break;
									case "@":
										//v = new Var();
										//v.assign(r.getRef());
										rv = new Ref(rref); //r.getRef();
										rv.xr = true;
										break;
									case "$":
										while (r.ty == 'r') r = r.rf;
										rv = sys.Resolve(this, r);
										//ex("$ Not implemented yet");
										break;
									default:
										exn($"Unknown operator '{si.con}'");
										rv = mkv('0'); // new Var('0');
										break;
								}
								pushv(rv);
								goto nxi;
						}
						break;
					case 'a':
						if (si.con == "break" || si.con == "continue")
						{
							while (ts.Count > 1 && !"fwd".Contains(ts.Last().t.p.ty))
							{
								popt();
							}
							popt();
							endv();
							if (si.con == "break") ts.Last().i++; // Move past the loop
							return;
						}
						else if (si.con == "var")
						{
							if (si1 == null || si1.ty != 'a') ex("No name following 'var'");
							st.vdecl = true;
							goto nxi;
						}
						if (st.vdecl)
						{
							//var sc = fvsc(si.con);
							//if (sc == null)
							//{
							//	rv = decl(si.con);
							//}
							//else if ("fwd".Contains(sc.t.ty))
							//{
							//	rv = sc.v[si.con];
							//}
							//else { ex($"Var already declared in this scope: {si.con}"); rv = null; }

							rv = decl(si.con);


							//el = fvscel(si.con); // find variable scope element
							//if (el == null)
							//{
							//	rv = decl(si.con); // new var
							//	//rv.sc = 
							//}
							//else if ("fwd".Contains(el.t.ty)) // for, while, do
							//{
							//	rv = el.sc[si.con];
							//}
							//else { ex($"Var already declared in this scope: {si.con}"); rv = null; }

							pushv(rv);
							st.vdecl = false;
							goto nxi;
						} // vdecl
						  // Not a variable declaration, evaluate identifier

						//v = fv(si.con);
						//Ref vr = fv(si.con);
						rv = fv(si.con);
						if (isnr(rv)) ex($"Var '{si.con}' not found", si);
						//pushv(v);
						pushv(rv);
						goto nxi;

					case 'R': // return
						switch (ph)
						{
							case 0:
								begv();
								pusht(si);
								goto nxp;
							case 1:
								// unwind stack until out of function or top
								rv = popv();
								endv();
								ends();
								while ((ts.Count > 0) && (ts.Last().t.ty != 'T'))
								{
									//Token tptmp;
									//if (!ts.Last().t.p.TryGetTarget(out tptmp)) ex("Token life cycle error");
									//if (tptmp.ty == 'u') break; else popt();
									if (ts.Last().t.p.ty == 'u') break; else popt();
								}
								//if (ts.Count > 0) { popt(); }
								if (ts.Count > 1) { popt(); }
								pushv(rv);
								//if (ts.Count == 0)
								if (ts.Count <= 1)
								{
									SoftEnd();
								}
								return;
						}
						break;
					case 'u':
						// Reaching a function in a sub element iteration means we're parsing over it, not calling it.
						// The function calling magic is in '('. But this is an expression like everything else that needs
						// to push its evaluated value, in this case a function variable, to the internal var stack.
						//v = new Var('u');
						//v.name = si.con;
						rv = mkv('u', si.con);
						rv.v.t = si;
						rv.v.sc = ss.Last();
						pushv(rv);
						goto nxi;
					case 'q':
					case 'Q':
						rv = mkv(); //new Var(si.con);
						rv = si.con;
						pushv(rv);
						goto nxi;
					case 'n':
						rv = mkv(); // new Var(si.con); //double.Parse(si.con));
						if (si.con.Length > 0 && si.con[0] == '#') { rv.v = Var.htc(si.con); }
						else if (si.con.StartsWith("0x"))
						{
							rv = Convert.ToUInt64(si.con.Substring(2), 16);
						}
						else rv = double.Parse(si.con);
						if ((rv.v.n > 4503599627370495) && (rv.v.n < (double)1.8446744073709551616e19) && (!si.con.Contains('.')))
						{
							rv.v = long.Parse(si.con);
						}
						//rv = rv.v.num;
						pushv(rv);
						goto nxi;
					case '.':
						//if (psi == null || si1 == null) ex("Dot (.) missing operands");
						if (si1 == null) ex("Dot (.) missing operands", si);
						switch (si1.ty)
						{
							case 'a':
							case 'q':
							case 'Q':
								break;
							default:
								ex("Syntax error following '.'");
								break;
						}
						//v = iv.Pop()[si.con];
						//iv.Push(v[si1.con]);
						Var vpop = popv();
						rv = vpop[si1.con];
						pushv(rv); //v[si1.con]);
						st.i++; // consume the next symbol
						goto nxi;
					case ':':
						break;
					case '[':
						if (si.sub.Count == 0)
						{
							//pushv(new Var('a'));
							pushv(mkv('a'));
							goto nxi;
						}
						switch (ph)
						{
							case 0:
								//st.vsc = vs.Count;
								l = popv();
								begv();
								pushv(l);
								pusht(si);
								goto nxp;
							case 1:
								r = popv();
								l = popv();
								endv();
								//iv.Push(l[r]);
								pushv(l[r]);
								goto nxi;
						}
						goto nxi;
					case '(':
						// This is where function calls happen
						if (ph == 0)
						{
							if (vs.Count == 0) { pusht(si); goto nxi; }
							if (t.ty == 'u' && i == 0)
							{
								// receiving arguments of a function call
								var sc = pushs(si);
								//vsel x; // idk what to call this, the internal var stack element currently being popped, need access to the token as well
								el = ts[ts.Count - 1];
								// Move the arguments off the stack into local variables
								if (si.sub.Count > 0)
								{
									//if (el.sc == null) el.sc = new Dictionary<string, Var>();

									bool fnPopped = false;
									if (si.sub[0].ty == ',')
									{
										for (int iArg = 0; iArg < si.sub[0].sub.Count; iArg++)
										{
											Token tar = si.sub[0].sub[iArg].sub[0]; // '(' --> ',' --> '(' --> 'a'
											if (tar.ty != 'a') ex("Bad parameter name", tar);
											if (!fnPopped)
											{
												//x = vs.Pop();
												//rv = x.rv.v;
												rv = popv();
												//if (Object.ReferenceEquals(x.t, t)) goto fnPopped;
												if (!Object.ReferenceEquals(rv.v, null) &&
													Object.ReferenceEquals(rv.v.t, t)) fnPopped = true;
											}
											else rv = mkv('0'); // new Var('0');
											rv.v.name = tar.con;
											//el.sc[tar.con] = rv;
											sc.v[tar.con] = rv;
										}
									}
									else
									{
										if (si.sub[0].ty != 'a') ex("Bad parameter name", si.sub[0]);
										if (!fnPopped)
										{
											//x = vs.Pop();
											//rv = x.v;
											rv = popv();
											//if (Object.ReferenceEquals(x.t, t)) goto fnPopped;
											if (!Object.ReferenceEquals(rv.v, null) && Object.ReferenceEquals(rv.v.t, t)) fnPopped = false; //goto fnPopped;
										}
										rv.v.name = si.sub[0].con;
										//el.sc[v.name] = x.v;
										//el.sc[rv.v.name] = rv;
										sc.v[rv.v.name] = rv;
										// single argument
									}
								}
								// Unwind the internal stack until we reach the function itself
								// TODO: var_args? Although I think that would already work.
								// TODO: Also, why would vs.count == ts.vsc?
								do
								{
									//x = vs.Pop();
									rv = popv();
								} while (!Object.ReferenceEquals(rv.v, null) && !Object.ReferenceEquals(rv.v.t, t) && vs.Count > ts.Last().vsc);
								//fnPopped:
								// start executing function
								// ... do we need to do anything here? next i is {}
								goto nxi;
							}
							Var fnv = vs.First().rv.v; // function variable ?
							fnv.su();
							if (fnv.ty == 'u' && i > 0) // calling a function. i > 0 means there was an identifier in the statement prior to the ()
							{
								//begv();
								// If fnv is a system call variable, or if it's an indexed method of a system object (fa meaning "from array" is 'this')
								// if (fnv.sy == null)
								if (!fnv.isSystemVar)
								{
									// script defined function
									pusht(fnv.t); // evaluate (call) the function. This token is 'u', but the first sub iteration is the '(' parameter list
									if (fnv.sc != null && !fnv.isSystemVar)
									{
										// Function is packaged with a scope, for captured variables.
										// Need another phase that knows to pop the scope stack after.
										// Also, we don't want to use pushs() here because we don't want
										// to link it up the token stack, necessarily. The function might be
										// a closure from a tighter scope, whose parent chain might take a
										// different path.


										ss.Add(fnv.sc); // Push the scope of any captured variables
										pushs(fnv.t); // Push a new scope for anything declared in the function

										st.ph = 3;
									}
								}
								if (si.sub.Count > 0 && si.sub[0].ty == ',')
								{
									// multiple arguments
									//for (int iArg = si.sub[0].sub.Count - 1; iArg >= 0; iArg--)
									for (int iArg = 0; iArg < si.sub[0].sub.Count; iArg++)
									{
										pusht(si.sub[0].sub[iArg]);
									}
								}
								else if (si.sub.Count > 0)
								{
									pusht(si);
									// single argument
								}
								//if (fnv.sy != null || ((fnv.fa != null) && (fnv.ak != null) && (fnv.fa.sy != null)))
								if (fnv.isSystemVar)
								{
									// system call
									st.ph = 2;
									st.scv = fnv;
									return;
									//fnv.sy.call(fnv, vs);
									//goto nxi;
								}

								// If we pushed a scope, the next phase is already set,
								// don't fall through and auto increment.
								if (st.ph == 3) { return; }

								//st.ivc = iv.Count();
								//goto nxp;
							}
							else
							{
								pusht(si);
							}
						}
						else if (ph == 1)
						{
							// It only gets here if the function contains no return statement.
							// Return unwinds the stack.

							//if (iv.Count <= st.ivc) { ivpush(new Var('0')); }
							//endv();
							// TODO: This might not even be necessary due to the safety in popv(), maybe test that
							pushv(mkv('0')); // new Var('0'));
											 //pops();
						}
						else if (ph == 2)
						{
							if (st.scv == null) ex("Internal error making system call", si);
							//st.scv.sy.call(st.scv, vs);
							if (st.scv.sy != null)
							{
								st.scv.sy.call_internal(st.scv); //, this);
							}
							else if (((st.scv.fa != null) && (st.scv.ak != null) && (st.scv.fa.sy != null)))
							{
								//Read: token stack top -> system call var -> from array ('this') -> system -> CallMethodInternal
								st.scv.fa.sy.CallMethodInternal(st.scv.fa, st.scv.ak); // ak = array key (the name of the method)
							}
							st.scv = null;
							//pops();
							goto nxi;
						}
						else if (ph == 3)
						{
							// function var had a scope attached, need to pop that
							//ss.RemoveAt(ss.Count - 1);
							ends();
							// Var stack now looks like (outer statement) > (this function variable) > (return value)
							// Need to remove the function and put the return value back.
							var res = popv();
							endv();
							pushv(res);
						}
						goto nxi;
					// Flow
					case 'i':
						if (si.sub.Count == 0 || si.sub[0].ty != 'c') ex("'if' missing condition");
						pusht(si);
						goto nxi;
					case 'c':
						// TODO: check if parent is 'if' or 'switch'
						if (st.t.ty == 'i')
						{
							//if (si.sub.Count != 2 || si.sub[0].ty != '(' || si.sub[1].ty != '{') ex("Syntax error in 'if' block");
							switch (ph)
							{
								case 0:
									//st.ivc = iv.Count();
									begv();
									pusht(si.sub[0]);
									goto nxp;
								case 1:
									rv = popv();
									endv();
									if (rv.v.tr)
									{
										popt(); // Escape from 'if' block, condition met
										pusht(si.sub[1]);
										return;
									}
									goto nxi;
							}
							goto nxi;
						}
						break;
					case 'e':
						// If we reach this point, other conditions have failed.
						if (si.sub.Count != 1 || si.sub[0].ty != '{') ex("Syntax error near 'else'");
						popt();
						pusht(si.sub[0]);
						return;
					case 'w':
						switch (ph)
						{
							case 0:
								//if (si.sub.Count != 2 || si.sub[0].ty != '(' || si.sub[1].ty != '{') ex("Syntax error near 'while'");
								begv();
								pusht(si.sub[0]);
								goto nxp;
							case 1:
								rv = popv();
								endv();
								if (rv.v.tr)
								{
									// go inside {}
									pusht(si.sub[1]);
									pushs(si.sub[1]);
									st.ph = 0;
									return;
								}
								goto nxi;
						}
						break;
					case 'd':
						switch (ph)
						{
							case 0:
								begv();
								pusht(si.sub[0]);
								goto nxp;
							case 1:
								endv();
								begv();
								pusht(si.sub[1]);
								pushs(si.sub[1]);
								goto nxp;
							case 2:
								rv = popv();
								endv();
								if (rv.v.tr)
								{
									st.ph = 0;
									return;
								}
								goto nxi;
						}
						break;
					case 'f':
						switch (ph)
						{
							case 0:
								// initializer statement
								begv();
								pusht(si.sub[0].sub[0]);
								goto nxp;
							case 1:
								// set up condition check
								popv();
								endv();
								pusht(si.sub[0].sub[1]);
								goto nxp;
							case 2:
								// condition evaluated, go inside {}
								rv = popv();
								endv();
								if (rv.v.tr)
								{
									begv();
									pusht(si.sub[1]);
									pushs(si.sub[1]);
									goto nxp;
								}
								goto nxi;
							case 3:
								// set up loop iteration statement
								endv();
								begv();
								pusht(si.sub[0].sub[2]);
								goto nxp;
							case 4:
								// finish iteration statement and go back to condition
								popv();
								endv();
								st.ph = 1;
								return;
						}
						break;
					case 's':
						// TODO:
						ex("'switch' statements not supported", si);
						break;
					case 'l':
					case 'r':
						ex("Internal error: left/right operands should have been handled by operator");
						break;

					case 'I': // watch ... like an eye ...
						if (ph == 0)
						{
							if (si.sub.Count < 2 || si.sub[0].ty != '(' || si.sub[1].ty != '{') ex("Syntax error, expected 'watch (var) { ... }'");
							begv();
							pusht(si.sub[0]);
							goto nxp;
						}
						if (ph == 1)
						{
							rv = popv();
							endv();
							var wt = new Watch();
							wt.t = si;
							wt.v = rv;
							wt.prev = mkv(); //new Var(v);
							wt.prev.assign(rv);
							if (rv.v.w == null) rv.v.w = new List<int>();
							rv.v.w.Add(wt.id);
							// condense scopes
							//for (var isc = ts.Count - 1; isc >= 0; isc--) md(wt.sc, ts[isc].sc, false);
							for (var isc = ss.Count - 1; isc >= 0; isc--) md(wt.sc, ss[isc].v, false);
							wt.sc["_watch_id"] = wt.id;
							watches.Add(wt.id, wt);
							if (rv.v.sy != null) rv.v.sy.watch(rv);
							pushv((Var)wt.id);
						}
						goto nxi;
					case 'J': // unwatch
						if (ph == 0)
						{
							begv();
							pusht(si);
							goto nxp;
						}
						else if (ph == 1)
						{
							rv = popv();
							endv();
							if (rv == null)
							{
								rv = fv("_watch_id");
								if (isnr(rv)) ex("unwatch: no id");
							}
							while (rv.v.ty == 'r') rv = rv.v.rf;
							if (rv.v.ty != 'n') ex("'unwatch' id must be a number/integer", si);
							int wk = (int)rv.v.n;
							if (watches.ContainsKey(wk))
							{
								Var wv = watches[wk].v;
								watches.Remove((int)rv.v.n);
								wv.w.Remove(wk);
								if (wv.sy != null) wv.sy.unwatch(wv);
							}
							goto nxi;
						}
						break;
					case 'A': // wait
						if (ph == 0)
						{
							begv();
							pusht(si);
							goto nxp;
						}
						if (ph == 1)
						{
							rv = popv();
							endv();
							wakeTime = DateTime.Now + TimeSpan.FromSeconds(rv.v);
							//sch.anySleeping = true;
							sleeping = true;
							Status = State.WAIT;
						}
						goto nxi;
					case 'M': // import / run
						switch (ph)
						{
							case 0:
								pusht(si);
								goto nxp;
							case 1:
								rv = popv();
								string src = sys.GetSource(rv.v.str);
								if (src.Length > 0)
								{
									if (si.con == "run")
									{
										if (sch == null) ex("No scheduler", si);
										sch.Load(src, rv.v.str, sys);
										goto nxi;
									}
									begv();
									tzs.Push(new Tokenizer());
									st.extra = tz.top; // to prevent garbage collection after sub script is done
									tz.LoadStart(src, rv.v.str);
									sourceName = rv.v.str;
									Status = State.LOAD;
								}
								//begv();
								goto nxp;

							case 3:
								rv = popv();
								endv();
								pushv(rv);
								goto nxi;
						}
						goto nxi;

					// TODO: try/catch/finally
					case 't':
						break;
					case 'h':
						break;
					case 'y':
						break;

					default: // token type
							 //ex($"Unknown token '{st.t.con}' (type '{st.t.ty}')", st.t);
						ex($"Unknown token '{si.con}' (type '{si.ty}')", si);
						break;
				} // token type

			nxp: // next phase
				st.ph++;
				return;
			stepOut:
				//rs.Pop();
				//if (rs.Last().t.ty == 'u') ivpush(new Var('0'));
				// popt();
				if (ts.Count > 1) popt();
				//if (ts.Count == 0)
				if (ts.Count <= 1 && ts.Last().i >= ts.Last().t.sub.Count)
				{
					//tst = State.TERM;
					SoftEnd();
				}
				return;
			nxi:  // next index (token)
				st.ph = 0;
				st.i++;
				return;
			}

			public int ln { get { if (ts.Count == 0) return 0; else return ts[ts.Count - 1].t.ln; } } // current line of source
			public int ch { get { if (ts.Count == 0) return 0; else return ts[ts.Count - 1].t.ch; } } // current character (horizontal from beginning of line)
			public void Unload() // ReturnValue will no longer be accessible
			{
				while (tzs.Count > 1)
				{
					sourceName = tz.sourceName;
					tz.top.Clear();
					tzs.Pop();
				}
				tst = State.TERM;
				ts.Clear();
				vs.Clear();
			}

			public void SoftEnd() // at end of script. There may still be waits active.
			{
				//pst = tst;
				if (watches.Count > 0) Status = State.WAIT;
				else
				{
					while (ts.Count > 0 && !Object.ReferenceEquals(ts.Last().t, tz.top)) popt();
					if (ts.Count > 1) popt();
					if (tzs.Count > 1) { tzs.Pop(); }
					if (tzs.Count > 0) { sourceName = tz.sourceName; }
					if (tzs.Count <= 1) { Status = State.TERM; return; }
					//Var v = popv();
					//endv();
					//pushv(v);
				}
			}

			public void HardExit(Var ret)
			{
				tst = State.TERM;
				pst = State.TERM;
				ts.Clear();
				vs.Clear();
				pushv(ret);
				// Clean up watches
				//tz
			}

			public void TriggerWatch(int wid)
			{
				if (watches.ContainsKey(wid)) TriggerWatch(watches[wid]);
			}
			public void TriggerWatch(Watch w)
			{
				pusht(w.t);
				var st = ts.Last();
				//st.sc = w.sc; // maintain the sanctity of this scope, new local vars inside watch{} should not propagate out,
				// although values from source scope can be changed
				//st.sc = new Dictionary<string, Var>();
				//foreach (var kv in w.sc) st.sc.Add(kv.Key, kv.Value);
				//st.sc = new Scope(st.t);
				var sc = pushs(st.t); // TODO: Where is this being popped?
				foreach (var kv in w.sc) sc.v.Add(kv.Key, kv.Value);
				st.i = 1;
				w.prev.assign(w.v, true);
				Status = State.RUN;

			}

		} // class EZThread


		class Scheduler
		{
			public List<Thread> ths = new List<Thread>(); // threads
			int ith = 0;
			public long[] cumSteps; // cumulative steps spent on each state
			public bool showInternalErrs = false;
			public Thread Load(string sourceCodeText, string sourceName, ISystem sys)
			{
				var th = new Thread(sourceCodeText, sourceName, sys, this);
				th.showInternalErrs = showInternalErrs;
				stCount[Thread.State.LOAD]++;
				ths.Add(th);
				ReCountStates();
				return th;
			}
			public int Kill(string sourceName)
			{
				// TODO: Cleanup resources
				//int i;
				int ret = 0;
				ret += mkst(sourceName, Thread.State.TERM);
				ReCountStates();
				return ret;
			}
			public int Suspend(string sourceName)
			{
				return mkst(sourceName, Thread.State.SUSP);
			}
			public int Resume(string sourceName)
			{
				return mkst(sourceName, Thread.State.RUN);
			}

			int mkst(string sn, Thread.State st) // set thread state (by name)
			{
				int ret = 0;
				for (int i = 0; i < ths.Count; i++)
				{
					if (ths[i].sourceName == sn)
					{
						if (st == Thread.State.SUSP) ths[i].pst = ths[i].tst;
						else if (st == Thread.State.RUN) ths[i].tst = ths[i].pst;
						else if (st == Thread.State.TERM)
						{
							foreach (var w in ths[i].watches)
							{
								// clear watches
								w.Value.v.v.w = null;
							}
							ths[i].watches.Clear();
							if (autoUnload) { ths[i].Unload(); ths.RemoveAt(i); i--; }
							else ths[i].tst = Thread.State.TERM;
						}
						else ths[i].tst = st;
						ret++;
					}
				}
				return ret;
			}
			public void GetThreadNames(List<string> tns)
			{
				tns.Clear();
				foreach (var el in ths)
				{
					tns.Add(el.sourceName);
				}
			}
			public Thread GetThread(string name)
			{
				return ths.Find((th) => th.sourceName == name);
			}
			//public int RunnableCount { get { return ths.Count((t) => (t.tst == Thread.State.RUN || t.tst == Thread.State.LOAD)); } }
			public int RunnableCount { get { return stCount[Thread.State.LOAD] + stCount[Thread.State.RUN]; } }
			//public int WaitingCount { get { return ths.Count((th) => (th.tst == Thread.State.WAIT)); } }
			public int WaitingCount { get { return stCount[Thread.State.WAIT]; } }
			public int SuspCount { get { return stCount[Thread.State.SUSP]; } }
			public int TermCount { get { return stCount[Thread.State.TERM]; } }
			public bool autoUnload = true;
			public Scheduler()
			{
				cumSteps = new long[Enum.GetValues(typeof(Thread.State)).Length];
				foreach (var s in Enum.GetValues(typeof(Thread.State)).Cast<Thread.State>())
				{
					stCount[s] = 0;
					//stAcc[s] = 0;
				}
				//threadStates[Thread.State.ERR] = 0;
			}
			public int Unload()
			{
				int ret = 0;
				for (int i = 0; i < ths.Count; i++)
				{
					switch (ths[i].tst)
					{
						case Thread.State.ERR:
						case Thread.State.TERM:
							ths[i].Unload();
							ths.RemoveAt(i);
							i--;
							ret++;
							break;
					}
				}
				ReCountStates();
				return ret;
			}
			public void ReCountStates()
			{
				//foreach (var tmp in stAcc) { stCount[tmp.Key] = tmp.Value; }
				var ks = new List<Thread.State>();
				ks.AddRange(stCount.Keys);
				foreach (var tmp in ks) { stCount[tmp] = 0; }
				for (int i = 0; i < ths.Count; i++)
				{
					//stAcc[ths[i].tst]++;
					stCount[ths[i].tst]++;
				}
			}

			Dictionary<Thread.State, int> stCount = new Dictionary<Thread.State, int>();
			public DateTime nextWake = DateTime.Now;
			public bool anySleeping = false;

			public void CheckWake()
			{
				bool needWakeTime = false;
				anySleeping = false;
				if (nextWake <= DateTime.Now) needWakeTime = true;

				for (int i = 0; i < ths.Count; i++)
				{
					var th = ths[i];

					if (th.Status == Thread.State.WAIT)
					{
						if (th.sleeping)
						{
							if (th.wakeTime <= DateTime.Now)
							{
								stCount[th.tst]--;
								th.Status = Thread.State.RUN;
								stCount[th.tst]++;
								//th.sleepUntil = 0;
								th.sleeping = false;
								needWakeTime = true;
							}
							else
							{
								anySleeping = true;
							}
							if (needWakeTime && th.sleeping)
							{
								nextWake = th.wakeTime;
							}
							if (th.sleeping && th.wakeTime < nextWake) nextWake = th.wakeTime;
							//			&& (th.sleepUntil < nextWake)) nextWake = th.sleepUntil;
						}

					}
				}
			}
			public void CheckAllWatches()
			{
				//bool fresh = false;
				for (int i = 0; i < ths.Count; i++)
				{
					var th = ths[i];
					if (th.watches.Count > 0)
					{
						foreach (var wp in th.watches)
						//for (int iw = 0; iw < th.watches.Count; iw++)
						{
							var w = wp.Value; // th.watches.Keys[iw];
											  // TODO: Store _watch_id in scope, make watch token evaluate to id so script can store id in a var, unwatch(optional id)
											  // also unwatch("all")
											  //if (w.Value.prev != w.Value.v)
							w.v.v.su();
							if (w.prev != w.v)
							{
								////th.pusht(w.Value.t);
								////th.ts.Last().sc = w.Value.sc;
								//th.TriggerWatch(w.Value);

								//// TODO: Remove debug print when working
								//var prfn = th.fv("print");
								//if (prfn != null && prfn.sy != null)
								//{
								//	th.pushv(prfn);
								//	th.pushv(" dbg:trigger ");
								//	prfn.sy.call(prfn);
								//}

								stCount[th.tst]--;
								th.TriggerWatch(w);
								//th.Status = Thread.State.RUN;
								stCount[th.tst]++;
								//fresh = true;
							}
						}
					}
					//if (fresh) RefreshThreadState();
				}
			}

			void RefreshThreadState()
			{
				foreach (var ek in Enum.GetValues(typeof(Thread.State)).Cast<Thread.State>()) { stCount[ek] = 0; }
				foreach (var th in ths) { stCount[th.Status]++; }
			}

			//int ph = 0 ;
			public void Step()
			{
				if (anySleeping && DateTime.Now <= nextWake) CheckWake();
				if (ths.Count == 0) return;
				if (ith >= ths.Count)
				{
					ith = 0;
				}
				var th = ths[ith];
				Thread.State stBefore = th.tst;
				cumSteps[Convert.ToInt32(stBefore)]++;
				switch (th.tst)
				{
					case Thread.State.LOAD:
						th.step();
						break;
					case Thread.State.RUN:
						th.step();
						try
						{
							if (th.Status == Thread.State.ERR && th.ts.Count > 0
								//&& th.ts[0].sc != null
								//&& th.ts[0].sc.ContainsKey("print")
								//&& th.ts[0].sc["print"].sy != null)
								&& th.ss.Count > 0
								//&& th.ss.Last().v.ContainsKey("print")
								//&& th.ss.Last().v["print"].sy != null)
								)
							{
								// if system provided a print function, use that to display the error message
								//Var vpr = th.ts[0].sc["print"];
								//Var vpr = th.ss.Last().v["print"];
								// ^ varPrintFunction = thread -> tokenStack [bottom] -> scope ["print"]
								// kinda weird because bottom really means top, or root token,
								// but that's the bottom of the stack, first to come and last to go

								Var vpr = th.fv("print", false);
								if (vpr != null && vpr.sy != null)
								{
									th.pushv(vpr);
									th.pushv((Var)(" E " + th.err.Message));
									vpr.sy.call_internal(vpr);
								}
							}
						}
						catch { }
						if (autoUnload && (th.Status == Thread.State.TERM || th.Status == Thread.State.ERR))
						{
							ths[ith].Unload();
							ths.RemoveAt(ith);
						}
						break;
					case Thread.State.ERR:
						if (autoUnload)
						{
							ths[ith].Unload();
							ths.RemoveAt(ith);
							ith--;
						}
						break;
					case Thread.State.TERM:
						// TODO: is another thread waiting on this one?
						if (autoUnload)
						{
							ths[ith].Unload();
							ths.RemoveAt(ith);
							ith--;
						}
						break;
				}
				stCount[stBefore]--;
				stCount[th.tst]++;
				ith++;
				//ph = 0;
			}
		}

		struct vsel // variable stack element
		{
			//public Var v;
			public Ref rv;
			// If this ends up being necessary, update pushv()
			//public Token t = null;
			//public static implicit operator vsel(Var vp) { return new vsel { v = vp }; }
			public static implicit operator vsel(Ref p_rv) { return new vsel { rv = p_rv }; }
			public override string ToString() // for debugging
			{
				return rv.ToString();
			}
		};
		class Scope
		{
			public Scope p; // parent
			public Dictionary<string, Var> v = new Dictionary<string, Var>(); // vars
			public Token t;
			public bool iso;
			public Scope(Token p_token)
			{
				p = null;
				v = new Dictionary<string, Var>();
				t = p_token;
			}
			public Scope(Token p_token, Scope parent = null)
			{
				p = parent;
				v = new Dictionary<string, Var>();
				t = p_token;
			}
		}
		class tsel // token stack element
		{
			public tsel(Token tp) { t = tp; }
			public Token t;
			//public Dictionary<string, Var> sc; // scope
			//public Scope sc;
			public int ph = 0; // phase, used for control statements with multiple stages
			public int i = 0;  // index or iterator used to track token sub elements
			public int vsc; // internal var count - size of internal stack at phase 0 of token
			public int ssc; // scope stack count - size of scope stack at start of phase 0
			public bool vdecl;
			public bool iso = false; // isolate scope
			public Var scv = null; // system call variable
			public object extra; // extra storage for whatever - initially a token for the top of a "run" or "import" tokenizer
		};

		interface ISystem
		{
			Ref Resolve(Thread th, Var request); // Handler for '$' ...  $"block".property = value;  return a reference to enable scripts to 'watch' it
			void InitScope(Thread th, Dictionary<string, Var> sc); // Provide system calls and globals
			string GetSource(string sourceName); // when scripts import("something");
		}
		class SysVar
		{
			public SysVar(object cx_p) { cx = cx_p; }
			public static Var New(object cx_p, Thread th)
			{
				Var r = th.mkv('0');
				r.sy = new SysVar(cx_p);
				return r;
			}
			//delegate void VarUpdateFn(Var v); // read
			public delegate void VarReadFn(Var v);
			public delegate void VarAssignFn(Var v, Var value);
			public delegate Var VarReadIndexFn(Var v, Var index);
			public delegate void VarAssignIndexFn(Var v, Var index, Var value);
			//public delegate void VarCallFn_old(Var fn); // popv() until you reach a 'u' element (.v.ty=='u') (pop that too) then push return value
			public delegate Var SysCallFn(object cx, List<Var> args);

			public delegate bool VarTruthyFn(Var v);
			public delegate void VarNotifyWatchingFn(Var v);
			public delegate Var PropertyGetFn(object cx);
			public delegate void PropertySetFn(object cx, Var value);
			public struct PropertyHandlerPair
			{
				public PropertyGetFn get;
				public PropertySetFn set;
			}

			public object cx;
			//public VarUpdateFn update = NullUpdate; // It's the framework/environment's job to update its vars as needed in between the Step() cycle. 
			public VarReadFn read = NullRead;
			public VarAssignFn assign = NullAssign;
			public VarReadIndexFn readIndex = NullReadIndex;
			public VarAssignIndexFn assignIndex = NullAssignIndex;
			public SysCallFn call = NullCall;
			public Var readIndexInternal(Var v, Var index)
			{
				//var con = g_prg.GridTerminalSystem.GetBlockWithName("BSS-Debug") as IMyTextPanel;
				//if (index == "HasPendingMessage")
				//{
				//	if (con != null)
				//	{
				//		con.WriteText("HasPendingMessage indexer", true);
				//	}
				//}


				// Take care, calling properties like Var.str or Var.num here may cause an infinite recursion via Var.su()
				if (index.ty == 's' && props.ContainsKey(index.s) && props[index.s].get != null)
				{
					Var ret = props[index.s].get(cx);
					return ret;
				}
				else if (index.ty == 's' && methods.ContainsKey(index.s))
				{
					// value is a method
					Var r = v.th.mkv();
					r.ty = 'u';
					r.s = v.name + "." + index.s;
					r.name = r.s;
					r.fa = v;
					r.ak = index.s;
					return r;
				}
				else
				{
					// Unknown index / not registered.
					return readIndex(v, index);
				}
			}
			public void assignIndexInternal(Var v, Var index, Var value)
			{
				if (index.ty == 's' && props.ContainsKey(index.s) && props[index.str].set != null)
				{
					props[index.str].set(cx, value);
				}
				else
				{
					// Unknown index / not registered
					assignIndex(v, index, value);
				}
			}

			//public VarCallFn_old call = NullCall;
			public VarTruthyFn truthy = (Var v) => v.tr;
			public VarNotifyWatchingFn watch = NullWatch; // Not a trigger, just allows framework to minimize polling by knowing what the script is interested in.
			public VarNotifyWatchingFn unwatch = NullWatch;
			//Dictionary<string, Tuple<PropertyGetFn, PropertySetFn>> props;
			public Dictionary<string, PropertyHandlerPair> props = new Dictionary<string, PropertyHandlerPair>();
			public void AddProp(string name, PropertyGetFn get, PropertySetFn set = null)
			{
				// TODO: implement calling these
				//props[name] = new Tuple<PropertyGetFn, PropertySetFn>(get, set);
				props[name] = new PropertyHandlerPair { get = get, set = set };
				read = (Var v) => v.ty = 'a';
			}
			public delegate Var Method(object cx, List<Var> args);
			public Dictionary<string, Method> methods = new Dictionary<string, Method>();
			public void AddMethod(string name, Method m) { methods[name] = m; }
			public void CallMethodInternal(Var vthis, string name)
			{
				if (!methods.ContainsKey(name)) { return; }
				var args = new List<Var>();
				Var a;
				for (int x = 0; x < 100 /*MAX_FUNCTION_CALL_PARAMS*/; x++)
				{
					a = vthis.th.popv();
					if (a.ty == 'u') break;
					args.Add(a);
				}
				vthis.th.pushv(methods[name](cx, args));
			}

			//public string ToString(Var v)
			//{
			//	int c = 0;
			//	if (methods != null) c += methods.Count;
			//	if (props != null) c += props.Count;
			//	if (c > 0) return $"SystemObject[{c}]";
			//	if (call != NullCall) return "SystemFunction()";
			//	if (readIndex != NullReadIndex) return "SystemObject[?]";
			//	read(v); return 
			//}

			public static void NullRead(Var v) { }
			public static void NullAssign(Var v, Var value) { v.assignFromSys(value); }
			//public static void NullUpdate(Var v) { }
			public static Var NullReadIndex(Var v, Var index)
			{
				if (index.ty == 'n' && v.a != null && v.a.Count > index.n) { return v.a[(int)index.n]; }
				else if (index.ty == 's' && v.d != null && v.d.ContainsKey(index.s)) { return v.d[index.s]; }
				return v.th.mkv('0');
			} // new Var('0'); }
			public static void NullAssignIndex(Var v, Var index, Var value)
			{
				if (index.ty == 'n' && v.a != null)
				{
					if (v.a.Count <= index.n) { v.a.Capacity = (int)index.n; }
					v.a[(int)index.n] = value;
				}
				else if (index.ty == 's' && v.d != null)
				{
					v.d[index.s] = value;
				}
			}
			public static Var NullCall(object cx, List<Var> args)
			{
				return null;
				//// TODO: Test what happens if we just return, does it clean up the stack?
				//while (v.th.VarStackDepth > 0 && v.th.popv().v.ty != 'u') { }
				//v.th.pushv(v.th.mkv('0')); //  new Var('0')) ;
			}
			public static void NullWatch(Var v) { }
			//public static Var mkFunction_old(Thread th, string name, object cx, VarCallFn_old fn)
			//{
			//	var sv = new SysVar();
			//	sv.call = fn;
			//	sv.cx = cx;
			//	Var v = th.mkv('u', name); //new Var(th, 'u');
			//	//v.name = name;
			//	v.sy = sv;
			//	return v;
			//}

			// Make Function - returns the function var which can be called from script
			public static Var mkfn(Thread th, string name, object cx, SysCallFn fn)
			{
				Var r = th.mkv('u', name);
				r.sy = new SysVar(cx);
				r.sy.call = fn;
				r.sy.cx = cx;
				return r;
			}

			public void call_internal(Var v)
			{
				Var sv;
				var args = new List<Var>();
				for (int i = 0; i < 100; i++) // MAX_FUNCTION_ARGS
				{
					sv = v.th.popv();
					if (sv.ty == 'u' && sv.name == v.name) { break; }
					//if (ReferenceEquals(sv,null) || (sv.ty == 'u' && sv.name == v.name)) { break; }
					args.Add(sv);
				}
				v.th.pushv(call(cx, args));
			}

			//public static Var mkProp<T>(string name, T cx, Thread th, VarReadFn rd, VarAssignFn asn)
			//{
			//	var sv = new SysVar();
			//	Var v = th.mkv('?')
			//}

		} // SysVar

		class Ref
		{
			public Var v;
			public Dictionary<string, Var> sc = null;
			public string k = "";
			public bool xr = false; // explicit reference "@"
			private void iv(Var vp) { v = vp; } // init var
			public Ref(Var vp) { v = vp; }
			public Ref(Dictionary<string, Var> scp, string kp) { sc = scp; k = kp; v = sc[k]; }
			public static implicit operator Var(Ref vr) { return vr.v; }
			public static implicit operator Ref(Var v) { return new Ref(v); }
			public void AssignValue(Ref rp)
			{
				v.assign(rp.v);
				//if (k != null && k.Length > 0 && sc != null)
				//{
				//
				//}
			}
			public void AssignRef(Ref rp)
			{ // TODO: if xr copy sy

				//if (sc != null && k != "") sc[k] = v;
				//v = vp;

				v = rp;
				if (k != null && k.Length > 0 && sc != null)
				{
					sc[k] = rp.v;
				}

				//bool lr = xr || (k != null && sc != null);
				//bool rr = rp.xr || (rp.k != null && rp.sc != null);
				//if (!lr && !rr) // both values
				//{
				//	this.v.assign(rp.v);
				//}
				//else if (lr && !rr) // assign value to ref
				//{
				//	//v.assign(rp.v);
				//	//v = rp.v;
				//	//sc[k] = v;
				//	sc[k].assign(rp.v);
				//}
				//else if (!lr && rr) // assigning a reference to a var
				//{
				//	sc = rp.sc;
				//	k = rp.k;
				//	v = rp.v;
				//}
				//else if (lr && rr) // both references
				//{
				//	sc[k] = rp.v;
				//	sc = rp.sc;
				//	k = rp.k;
				//	v = rp.v;
				//}
				//////Var v = rp.v;
				////while (v.ty == 'r') v = v.rf;
				////if (k != null && sc != null) { sc[k] = v; }
				////sc = rp.sc;
				////v = rp.v;
				////k = rp.k;
			}
			public static implicit operator Ref(double n) { return new Ref((Var)n); }
			public static implicit operator Ref(string s) { return new Ref((Var)s); }
			public static implicit operator Ref(bool b) { return new Ref((Var)(b ? 1 : 0)); }
			public override string ToString() // for debugging purposes, not a method of serialization
			{
				if (k != null && k.Length > 0) return k + "@=" + v.name + "=" + v.ToString();
				else return v.name + "=" + v.ToString();
			}
		}


		// INCLUDE_END
		// INCLUDE_START

		class Var
		{
			public char ty; // type
							//	r	reference
							//	u	function
							//	s	string
							//	a	array
							//	n	number
							//	0	null

			public string s;
			public double n;
			public Token t = null;
			public Scope sc = null;
			public string name = "(rv)"; // default to an rvalue (temporary) with a name that the script can not reference (parentheses would be parsed out as a parent token)
										 //public List<Var> a = null;
										 //public ArrayList a = null;
			public List<Var> a = null;
			public Dictionary<Var, Var> d = null;
			public List<int> w = null; // watches on this
			public Thread th;
			public Var rf = null; // reference
			public Var fa = null; // From array - 'this' var was returned by indexing 'fa'
			public Var ak; // array key - fa[ak];

			//ISystem sys;

			// Native Property get/set, provide access to objects outside the script
			public SysVar sy = null;

			private Var() { ty = '0'; n = 0; }
			public Var(Thread pth) { th = pth; ty = '0'; }
			//public Var(Thread pth, char pty, SysVar psy) { th = pth; ty = pty; sy = psy; }
			public Var(Thread pth, char p_ty)
			{
				th = pth;
				ty = p_ty;
				if (ty == 'a')
				{
					//a = new ArrayList();
					a = new List<Var>();
					d = new Dictionary<Var, Var>();
				}
			}
			public Var(double pn) { ty = 'n'; n = pn; }
			public Var(string ps) { ty = 's'; s = ps; }
			public Var(int i) { ty = 'n'; n = (double)i; }
			//public static Var FromNullable<T>(Nullable<T> nu)
			//{
			//	if (nu.HasValue) { return new Var((T)nu.Value); }
			//	else return null;
			//}
			public Var(Var r)
			{
				th = r.th;
				assign(r);
			}
			public static Var byRef(Var v)
			{
				Var ret = new Var(v.th);
				ret.ty = 'r';
				while (v.ty == 'r') v = v.rf;
				//if (v.ty == 'r') ret.rf = v.rf;
				//else ret.rf = v;
				ret.rf = v;
				return ret;
			}
			public Var getRef()
			{
				return byRef(this);
			}
			public void setRef(Var target)
			{
				Reset();
				if (isn(target)) return;
				while (target.ty == 'r') target = target.rf;
				ty = 'r';
				rf = target;
			}
			public char Type
			{
				get
				{
					if (isn(this)) return '0';
					Var v = this;
					while (v.ty == 'r') v = v.rf;
					return v.ty;
				}
			}
			void exn(string msg) // Native Exception
			{
				throw new Exception(msg);
			}
			public void cpa(Var r) // Copy array (deep copy of variables, not references)
			{
				if (isn(this)) return;
				//a = new ArrayList();
				a = new List<Var>();
				d = new Dictionary<Var, Var>();
				apa(r);
			}

			public void su() // System Update, for system-held vars to update on read
			{
				if (sy != null)
				{
					sy.read(this);
				}
				else if (!isn(fa) && !isn(ak) && !isn(fa.sy))
				{
					// this is an indexed reference to a property of a system var.
					// Script: SomeObject.MyProperty or SomeObject["MyProperty"] 
					//   --> this.fa.sy has the system var reference to SomeObject, and
					//       this.ak is the key "MyProperty"
					// ("fa" == "from array" and "ak" == "array key")
					assignFromSys(fa.sy.readIndexInternal(fa, ak));
				}
			}
			public void apa(Var r) // append array (deep copy)
			{
				if (isn(r) || isn(this)) return;
				while (r.ty == 'r') r = r.rf; // r = right (side of equals), rf = reference
				su();
				r.su();
				//if (a == null) a = new ArrayList();
				if (a == null) a = new List<Var>();
				if (d == null) d = new Dictionary<Var, Var>();
				if (r.d != null)
				{
					foreach (var k in r.d.Keys)
					{
						Var v = new Var(r.d[k]);
						d[k] = v;
					}
				}
				if (r.a != null)
				{
					foreach (Var rv in r.a)
					{
						a.Add(new Var(rv));
					}
				}
			}
			public override string ToString()
			{
				//if (ncx) { }
				Var v = this;
				if (Object.ReferenceEquals(v, null)) { return "null"; }
				while (v.ty == 'r') v = v.rf;
				if (v.sy != null) return v.sy.ToString();
				v.su();

				if (isn(this)) return "null";
				switch (v.ty)
				{
					case 'n': return v.n.ToString();
					case 's': return v.s;
					case 'a':
						if (sy != null) return $"SystemObject[{sy.props.Count + sy.methods.Count}]";
						if (d != null && d.Count > 0) return $"Object[{d.Count}]";
						if (a != null) return $"Array[{v.a.Count}]";
						return "Array[0]";
					case '0': return "null";
					case 'u': return $"function {v.name}";
					default: throw new Exception("Value has unknown type");
				}
			}
			void Reset()
			{
				ty = '0';
				a = null;
				d = null;
				rf = null;
				sy = null;
			}

			// Light assign function that just copies a value, does not call system on SysVars. Needed to break infinite recursion.
			public void assignFromSys(Var cp)
			{
				// TODO: Is there a case where we need to copy fa/ak as a member? Currently I think it only
				// has these members if it's assigning back to the same var from the system evaluation.
				if (isn(cp)) { ty = '0'; return; }
				ty = cp.ty;
				switch (cp.ty)
				{
					case 's':
						s = cp.s;
						break;
					case 'n':
						n = cp.n;
						break;
					case 'a':
						// cpa(cp); // Infinite recursion trap
						a = new List<Var>(cp.a);
						d = new Dictionary<Var, Var>(cp.d);
						break;
					case '0':
						break;
					case 'u':
						t = cp.t;
						break;
					default:
						exn("Unknown var type");
						break;
				}
			}
			public void assign(Var cp, bool noWatch = false)
			{
				//Var b = cp; // store reference for debugging
				//Var v;
				if (Object.ReferenceEquals(this, null)) return;
				if (Object.ReferenceEquals(cp, null)) { Reset(); return; }
				//if (isn(this)) return;
				if (th == null) th = cp.th;
				Var me = this;
				// What should resolve and what should reference
				// Pretty sure if assigning to a reference, you modify the referenced object
				cp.su();
				while (me.ty == 'r') me = me.rf;
				// But, does assigning a reference to something mean the reference or the thing? ...
				// Answer: Store the reference. a = @b; first @ makes a ref var, then = assigns it here
				// Note: Could also say a @= b; which bypasses a few steps
				if (cp != null && cp.ty == 'r') { setRef(cp); return; }
				while (cp != null && cp.ty == 'r') cp = cp.rf;
				if (me.th == null) me.th = cp.th;
				if (me.sy != null)
				{
					//npset(ncx, cp);
					//sys.AssignVar(this, cp);
					assignFromSys(cp);
					me.sy.assign(me, cp);
					return;
				}
				else if (!isn(ak) && !isn(fa) && !isn(fa.sy))
				{
					// this is indexed from a system variable with a custom getter/setter
					me.fa.sy.assignIndexInternal(me.fa, me.ak, cp);
					return;
				}
				else if (isn(cp)) Reset();
				//if (cp.ncx != null)
				//{
				//	v = npget(cp.ncx);
				//}
				//while (cp.ty == 'r') cp = cp.rf;

				//else v = cp;
				me.ty = cp.ty;
				//ncx = cp.ncx;
				//sy = cp.sy;


				if (cp.a == null) me.a = null; else if (me.a != null) me.a.Clear();
				if (cp.d == null) me.d = null; else if (me.d != null) me.d.Clear();
				switch (cp.ty)
				{
					case 's':
						me.s = cp.s;
						break;
					case 'n':
						me.n = cp.n;
						break;
					case 'a':
						me.cpa(cp);
						break;
					case '0':
						break;
					case 'u':
						me.t = cp.t;
						me.sc = cp.sc;
						break;
					default:
						exn("Unknown var type");
						break;
				}
				if (!ReferenceEquals(me.fa, null) && !ReferenceEquals(me.ak, null))
				{
					me.fa[me.ak] = this;
					me.fa = null;
					me.ak = null;
				}
				me.sy = cp.sy;
				if (!noWatch && w != null) TriggerWatches();
			}
			public void TriggerWatches()
			{
				if (w == null) return;
				for (int iw = 0; iw < w.Count; iw++)
				{
					int wid = w[iw];
					th.TriggerWatch(wid);
					if (!th.watches.ContainsKey(wid)) { w.RemoveAt(iw); iw--; }
				}
			}
			public string str
			{
				get
				{
					su();
					return ToString();
				}
				set
				{
					//if (ncx != null && sys != null) { sys.AssignVar(this, value); }
					if (sy != null) sy.assign(this, value);
					else assign(value); //{ ty = 's'; s = value; }
				}
			}
			public static double htc(string cs) // hypertext color (html color code)
			{
				// HTML color code using a hash # reverses the byte order
				if (cs[0] != '#') { throw new Exception("Not an HTML color code, missing #"); }
				string stmp = cs.Substring(1);
				UInt32 tmp = Convert.ToUInt32(stmp, 16);
				if (stmp.Length == 6)
				{
					tmp = ((tmp & 0xFF) << 16) | ((tmp & 0xFF00)) | ((tmp & 0xFF0000) >> 16);

				}
				else if (stmp.Length == 3)
				{
					tmp = ((tmp & 0xF) << 20) | ((tmp & 0xF0) << 8) | ((tmp & 0xF00) >> 4);
				}
				//else return (double)(Convert.ToUInt32(v.s.Substring(1), 16));
				else throw new Exception("HTML color codes using # should be 3 or 6 digits, or use 0x prefix for non-translated hex.");
				return (double)tmp;
			}
			public double num
			{
				get
				{
					su();
					if (isn(this)) return 0;
					if (ty == 'n') return n;
					Var v = this;
					while (v.ty == 'r') v = v.rf;
					if (v.ty == 's')
					{
						if (v.s.Length > 0)
						{
							if (v.s[0] == '#')  // This should be done by parse, can we clean up some space here? Or do we want dynamic color code parsing... i guess
							{
								return htc(v.s);
							}
							else if (v.s.Length > 1 && v.s[0] == '0' && (v.s[1] == 'x' || v.s[1] == 'X'))
							{
								return (double)(Convert.ToUInt32(v.s.Substring(2), 16));
							}
							else return Convert.ToDouble(v.s);
						}
						else return 0;
					}
					else return 0;
				}
				set
				{
					assign(value);
					return;
					////if (ncx != null && sys != null) { sys.AssignVar(this, value); }
					//if (isn(this)) return;
					//Var v = this;
					//while (v.ty == 'r') v = v.rf;
					//if (v.sy != null) v.sy.assign(this, value);
					////else if (!isn(v.fa))
					//else { v.n = value; v.ty = 'n'; }
				}
			}

			public bool tr  // Truthy-ness
			{
				get
				{
					if (isn(this)) return false;
					Var v = this;
					v.su();
					while (v.ty == 'r') v = v.rf;
					switch (v.ty)
					{
						case 'n': return v.n != 0;
						case 's': return v.s.Length > 0;
						case 'a': return v.a.Count > 0 || v.d.Count > 0;
						case '0': return false;
						case 'u': return (v.t != null);
						default: exn("Unknown type"); return false;
					}
				}
			}

			public bool isSystemVar
			{
				get
				{
					return (sy != null) || (fa != null && fa.sy != null && ak != null);
				}
			}

			public static bool feq(double a, double b, double factor = 0.0001)
			{
				//double m = Math.Min(Math.Abs(a), Math.Abs(b)) * factor;
				double m = Math.Max(Math.Abs(a), Math.Abs(b)) * factor;
				return Math.Abs(a - b) < m;
			}
			public static implicit operator bool(Var v) { return v.tr; }
			public static implicit operator Var(bool b) { return new Var(b ? 1 : 0); }
			public static implicit operator Var(double pn) { return new Var(pn); }
			public static implicit operator Var(string ps) { return new Var(ps); }
			public static implicit operator string(Var v) { return v.str; }
			public static implicit operator double(Var v) { return v.num; }
			public static implicit operator float(Var v) { return (float)(v.num); }
			public static implicit operator int(Var v) { return (int)(v.num); }

			long g;
			bool ug;
			public static implicit operator long(Var v) { return v.ug ? v.g : (long)(v.num); }
			public static implicit operator Var(long pn)
			{
				Var v = new Var();
				v.ty = 'n'; // TODO: make a 'g' type?
				v.n = pn;
				v.g = pn;
				v.ug = true;
				return v;
			}

			public static Var operator +(Var l, Var r)
			{
				if (isn(l) || isn(r)) return null;
				Thread th = (l.th != null) ? l.th : ((r.th != null) ? r.th : null);
				if (isn(l) || isn(r)) return null;
				while (l.ty == 'r') l = l.rf;
				while (r.ty == 'r') r = r.rf;
				l.su(); r.su();
				if (l.ty == 's') return l.s + r.str;
				else if (r.ty == 's') return l.str + r.s;
				else if (l.ty == 'n' && r.ty == 'n') return l.n + r.n;
				else if (l.ty == 'a')
				{
					Var ret = new Var(th, 'a');
					ret.a.AddRange(l.a);
					if (r.ty == 'a')
					{
						ret.a.AddRange(r.a);
					}
					else
					{
						Var nv = new Var(r);
						if (nv.th == null) nv.th = th;
						ret.a.Add(nv); // new Var(r));
					}
					return ret;
				}
				else return new Var(th);
			}
			static void rqn(Var l, Var r) // Require Number
			{
				l.su(); r.su();
				if ((l.ty != 'n') || (r.ty != 'n')) throw new Exception("Operands must be numbers");
			}
			public static Var operator -(Var l, Var r)
			{
				if (isn(l) || isn(r)) return null;
				l.su(); r.su();
				while (l.ty == 'r') l = l.rf;
				while (r.ty == 'r') r = r.rf;
				rqn(l, r);
				return l.num - r.num;
			}
			public static Var operator *(Var l, Var r)
			{
				if (isn(l) || isn(r)) return null;
				l.su(); r.su();
				while (l.ty == 'r') l = l.rf;
				while (r.ty == 'r') r = r.rf;
				rqn(l, r);
				return l.num * r.num;
			}
			public static Var operator /(Var l, Var r)
			{
				if (isn(l) || isn(r)) return null;
				l.su(); r.su();
				while (l.ty == 'r') l = l.rf;
				while (r.ty == 'r') r = r.rf;
				rqn(l, r);
				return l.num / r.num;
			}
			public double cmp(Var r)
			{
				Var l = this;
				string aty, bty;
				l?.su(); r?.su();
				if (isn(l)) { aty = "0"; } else { while (l.ty == 'r') l = l.rf; aty = l.ty.ToString(); }
				if (isn(r)) { bty = "0"; } else { while (r.ty == 'r') r = r.rf; bty = r.ty.ToString(); }
				//string ts = a.ty.ToString() + b.ty.ToString();
				string ts = aty + bty;
				//if (a.ty == '0') return -1;
				//if (b.ty == '0') return 1;
				string ls;  // local string (since s was taken)
							//ArrayList la; // local array (since a was taken)
				List<Var> la; // local array (since a was taken)
				double lm;
				switch (ts)
				{
					case "00":
						return 0;
					case "0n":
						return -r.n;
					case "n0":
						return l.n;
					case "nn":
						return l.n - r.n;
					case "ss":
						return string.Compare(l.s, r.s);
					case "ns":
						return string.Compare(l.n.ToString(), r.s);
					case "sn":
						return string.Compare(l.s, r.n.ToString());
					case "aa": // Arrays: which is longer
						return l.a.Count + l.d.Count - r.a.Count - r.d.Count;
					case "an":
						return l.a.Count + l.d.Count - r.n;
					case "na":
						return l.n - r.a.Count - r.d.Count;
					//!SPACE: comparing an array to a string is rather esoteric, cut this out if code too large
					case "sa":
						if (r.d.Count > 0) return -1;
						ls = l.s;
						la = r.a;
						lm = 1;
						goto cmpsa;
					case "as":
						if (l.d.Count > 0) return 1;
						ls = r.s;
						la = l.a;
						lm = -1;
						goto cmpsa;
					default:
						if (l.ty == '0') return -1;
						if (r.ty == '0') return 1;
						if (l.ty == 'u' || r.ty == 'u') exn("Function objects can only be tested for equality, not compared or sorted. (Did you mean to call the function?)");
						exn($"Values can not be compared ({ts})");
						break;
				}
				return 0;
			//!SPACE: comparing an array to a string is rather esoteric, cut this out if code too large
			cmpsa:
				int ia = 0; // array index
				int istr = 0; // string index
				Var v;
				while (true)
				{
					if (ia >= la.Count)
					{
						//if (s.Length > istr) return lm;
						//if (s.Length < istr) return -lm;
						if (ls.Length > istr) return lm;
						if (ls.Length < istr) return -lm;
						return 0;
					}
					if (istr >= ls.Length)
					{
						if (la.Count > ia) { return -lm; }
						if (la.Count < ia) { return lm; }
						return 0;
					}
					v = la[ia] as Var;
					string cs = v.str;
					int cr; // compare result
							//for (int si = 0; si < cs.Length; si++)
					int lasi = 0; // local array string index
					while (istr < ls.Length && lasi < cs.Length)
					{
						cr = string.Compare(ls[istr].ToString(), cs[lasi].ToString());
						if (cr != 0) return lm * cr;
						istr++;
						lasi++;
					}

					// don't increment array index if the string ran out
					if (istr < ls.Length) ia++;
				}
			}
			public static bool operator ==(Var l, Var r)
			{
				if (isn(l))
				{
					//if (isn(r)) return true;
					//return false;
					return isn(r);
				}
				if (isn(r)) return false;
				l.su(); r.su();
				while (l.ty == 'r') l = l.rf;
				while (r.ty == 'r') r = r.rf;
				return l.Equals(r);
			}
			public static bool operator !=(Var l, Var r)
			{
				if (isn(l))
				{
					//if (isn(r)) return false;
					//return true;
					return !isn(r);
				}
				if (isn(r)) return true;
				l.su(); r.su();
				while (l.ty == 'r') l = l.rf;
				while (r.ty == 'r') r = r.rf;
				return !l.Equals(r);
			}
			static bool isn(object o) { return Object.ReferenceEquals(o, null); }
			static bool isn(Var v)
			{
				if (Object.ReferenceEquals(v, null)) return true;
				while (v.ty == 'r') v = v.rf;
				if (v.sy != null) { return false; }// TODO: su()? Might be a lot of overhead, but maybe some system vars need to actually be null... idk
				return v.ty == '0';
			}
			public override bool Equals(object o)
			{
				Var l = this;
				//bool isv = o.GetType().Name.EndsWith("Var");
				Var r = o as Var;
				if (isn(o) || isn(r))
				{
					return isn(l) || l.ty == '0';
				}
				l.su(); r.su();
				while (l.ty == 'r') l = l.rf;
				while (r.ty == 'r') r = r.rf;
				if (l.ty != r.ty) return false;
				switch (l.ty)
				{
					case 's': return l.s == r.s;
					case 'n': return l.n == r.n;
					case 'a': return (l.a == r.a) && (l.d == r.d);
					case 'u': return (Object.ReferenceEquals(l.t, r.t));
					case '0': return true; // both null
				}
				return true;
			}
			public override int GetHashCode()
			{
				Var v = this;
				if (isn(v)) return 0;
				su();
				while (v.ty == 'r') v = v.rf;
				switch (v.ty)
				{
					case 's': return v.s.GetHashCode();
					case 'n': return v.n.GetHashCode();
					case 'a': return v.a.GetHashCode() + v.d.GetHashCode();
					case 'u': return v.t.GetHashCode();
					case '0': return 0; // both null
				}
				return base.GetHashCode();
			}
			public Var this[Var k]
			{
				get
				{
					if (ReferenceEquals(this, null) || ReferenceEquals(k, null)) return null;
					su();
					return indexGet(k);
				}
				set
				{
					// This assigns by reference, as most objects in C#.
					// The interpreter should create the proper reference or instantiate a new value before passing it here.
					if (isn(this) || isn(k)) return;
					while (k.ty == 'r') k = k.rf;
					if (!isn(sy))
					{
						// Indexing a system variable with custom callback
						sy.assignIndexInternal(this, k, value);
						return;
					}
					switch (k.ty)
					{
						case 'n':
							//if (a == null) a = new ArrayList();
							if (a == null) a = new List<Var>();
							if (ty == '0') ty = 'a';
							while (a.Count <= (int)k.n) a.Add(null);
							a[(int)k.n] = value;
							break;
						case '0': return;
						default:
							if (d == null) d = new Dictionary<Var, Var>();
							d[k] = value;
							if (ty == '0') ty = 'a';
							break;
					}
					return;

					//else if (k.ty == '0')
					//Var v = indexGet(k);
					//if (Object.ReferenceEquals(v, null))
					//{
					//	if (k.ty == n)
					//	{
					//		if (a == null) a = new ArrayList();
					//		while (a.Capacity <= (int)k.n) a.Add(null);
					//		if (ReferenceEquals(a[(int)k.n], null)) a[(int)k.n] = new Var(value);
					//		else (a[(int)k.n] as Var).assign(value);
					//	}
					//}
					//v.assign(value);
				}
			}
			Var indexGet(Var k)
			{
				//if (ncx != null && sys != null)
				if (ReferenceEquals(this, null)) return null; // exn("Indexed a null value");
															  //if (ty == '0') goto retIndexWritable;
				Var v = this;
				Var ret;
				k.su();
				while (v.ty == 'r') v = v.rf;
				if (v.sy != null)
				{
					ret = th.mkv();
					//ret.sy = sy; // redundant?
					//ret.th = th;
					ret.fa = this;
					ret.ak = k;
					//ret = v.sy.readIndex(v, k);
					//if (ReferenceEquals(ret, null))
					//{
					//	ret = th.mkv();
					//	ret.fa = this;
					//	ret.ak = new Var(k);
					//}
					ret.su();
					return ret;
				}
				switch (v.ty)
				{
					case 's':
						if (k.ty == 'n')
						{
							ret = new Var(th, 's');
							ret.s = v.str[(int)k.n].ToString();
							return ret;
						}
						else exn("[]: index to string was non numeric");
						break;
					//case 'a':
					default: // Let's just have everything be an object, it kind of is anyway.
						switch (k.ty)
						{
							case 'a': exn("[]: An array can not be an index to another array"); break;
							case '0': return null; // exn("[]: null can not be an index"); break;
							case 'n':
								if (v.a == null)
								{
									goto retIndexWritable;
								}
								if (v.a.Count <= k.n)
								{
									v.a.Capacity = (int)k.n + 1;
									for (int ac = v.a.Count; ac < v.a.Capacity; ac++) v.a.Add(th.mkv('0')); //new Var('0'));
								}
								return v.a[(int)k.n] as Var;
							case 's':
								if (v.d == null) goto retIndexWritable;
								if (v.d.ContainsKey(k.s)) return v.d[k.s];
								goto retIndexWritable;
							default:
								exn("[]: Unknown index type"); break;
						}
						break;

				}
				//exn($"[]: value '{str}' can not be indexed");
				return null;
			retIndexWritable:
				ret = new Var(th, '0');
				switch (k.ty)
				{
					case 'n':
						if (a == null) { a = new List<Var>(); }
						//if (k.n >= a.Count) { a.Capacity = (int)n + 1; }
						while (k.n >= a.Count) { a.Add(null); }
						a[(int)k.n] = ret;
						if (ty == '0') ty = 'a';
						break;
					case 's':
						if (d == null) d = new Dictionary<Var, Var>();
						if (ty == '0') ty = 'a';
						d[k] = ret;
						break;
					default:
						exn("invalid array/object key");
						break;
				}
				//ret.fa = this;
				//ret.ak = new Var(k);
				return ret;
			}

		}; // Var

		class StEl // Stack Element
		{
			public Token t;
			public Token tkc = null; // commas need an extra token
			public int i = -1; // iteration counter
			public int pi = -1; // Previous i. Some things use this, some don't
			public int ph = 0; // phase, not to be confused with enum Ph for overall program state
			public StEl(Token tp) { t = tp; }
		}

		class Token
		{
			public char ty = '?'; // type
			public char m = '\"';
			public string con = ""; // contents
			public int ln = 0; // source line start of statement
			public int ch = 0; // start of statement, characters from beginning of line
							   //public int ch2 = 0; // end of statement, characters from beginning of line
							   //public int ln2 = 0; // source line  end of statement
							   //public WeakReference<Token> p = new WeakReference<Token>(null); // parent
			public Token p;
			public int idx; // index within parent
			public List<Token> sub = new List<Token>();  // nested sub levels
			public Dictionary<string, Token> lbls = null;
			public Dictionary<string, Token> fns = null;
			public int touched = 0;
			public void Clear()
			{
				p = null;
				//if (v != null) v.Clear();
				foreach (Token t in sub) { t.Clear(); }
				sub.Clear();
				ty = '?';
				con = "";
			}
			//~Token() { Clear(); }
			public override string ToString()
			{
				return $"{ln}:{ch} {ty}  {con}";
			}

		} // Token

		class Tokenizer
		{
			public enum State
			{
				LOADING,
				ERR,
				READY
			}
			State state;
			public State Status { get { return state; } }
			public string sourceName;
			string srctxt;
			public string sourceCodeText { get { return srctxt; } }

			int nextRandomId = 1;

			static readonly string[] Phases =
			{
			"READ",
			"FLOW",
			"COMMAS",
			"STATEMENTS",
			"LABELS",

			"SIGN",
			"ASGN",
			"BOOLOR",
			"BOOLXOR",
			"BOOLAND",
			"EQ",
			"CMP",

			"BITOR",
			"BITXOR",
			"BITAND",

			"SHIFT",

			"AS",
			"MD",
			"NOT",

			"AT",
			"SYS",

			"INDEX",
			"DONE",
		};

			delegate void PhFn(); // Phase Function
			Dictionary<string, PhFn> PhFns = new Dictionary<string, PhFn>(); // Phase handler functions
			string cp; // current phase
			int poi = 0; // phase order index
			void init()
			{
				PhFns["READ"] = read;
				PhFns["FLOW"] = Flow;
				PhFns["COMMAS"] = Commas;
				PhFns["STATEMENTS"] = Statements;
				PhFns["LABELS"] = labels;
				PhFns["SIGN"] = sign;
				PhFns["ASGN"] = () => bop(" = += /= -= *= @= &= |= ^= %= <<= >>= +^= ");
				PhFns["BOOLOR"] = () => bop(" || or ", " a - ");
				PhFns["BOOLXOR"] = () => bop(" ^^ xor ", " a - ");
				PhFns["BOOLAND"] = () => bop(" && and ", " a - ");
				PhFns["EQ"] = () => bop(" == != ");
				PhFns["CMP"] = () => bop(" >= <= > < <> ");
				PhFns["BITOR"] = () => bop(" | ");
				PhFns["BITXOR"] = () => bop(" +^ ");
				PhFns["BITAND"] = () => bop(" & ");
				PhFns["SHIFT"] = () => bop(" << >> ");
				PhFns["AS"] = () => bop(" + - | ^ ");
				PhFns["MD"] = () => bop(" * / & % mod ", " - a ");
				PhFns["EXP"] = () => bop(" ^ ");
				PhFns["NOT"] = () => uop(" ! ~ not ", " - a ", true);
				//PhFns["INC"] = () => uop(" ++ -- ", " - ", true); // TODO: Test greedy
				PhFns["AT"] = () => uop(" @ ", " - ", true);
				PhFns["SYS"] = () => uop(" $ ", " - ", false);
				PhFns["INDEX"] = index;
				PhFns["DONE"] = () => ex("Internal error: Tried to continue loading after done.");

			}
			public Tokenizer() { init(); }

			public Token top = null;

			void ex(string s, int l, int c) { throw new Exception($"{s} at line {l} ch {c}"); }

			void ex(string s) { ex(s, ln, ch); }
			void ex(string s, Token t) { ex(s, t.ln, t.ch); }
			bool isWhite(char c)
			{
				switch (c)
				{
					case ' ':
					case '\t':
					case '\r':
					case '\n':
						return true;
					default:
						return false;
				}
			}

			// Working vars for load() and supporting functions
			Token cur;
			Stack<Token> nest;
			int ln; // line number
			int ch; // character (column)
			char ty; // type
			string nl; // newline sequence
			string word = "";
			string s;
			bool hex = false;


			char c; // previous character
			char pc;
			int lf;
			int innl; // index of next new line sequence
			int iu; // update i next loop, or -1
			int en; // end of quoted/delimited string
			bool pwh = true; // previous character is whitespace

			Stack<StEl> stk; // load stack
			public void Load(string ps)
			{
				LoadStart(ps);
				while (LoadContinue()) { }
			}
			public void LoadStart(string ps, string pSourceName = "")
			{

				s = ps + " ";
				sourceName = pSourceName;
				srctxt = ps;
				if (s.IndexOf("\r\n") != -1) { nl = "\r\n"; }
				else if (s.IndexOf("\r") != -1) { nl = "\r"; }
				else if (s.IndexOf("\n") != -1) { nl = "\n"; }
				else { nl = Environment.NewLine; }
				top = new Token { ty = 'T', con = "top" };
				nest = new Stack<Token>();
				cur = top;
				ln = 1;
				ch = 0;
				ty = '?';
				c = ' ';
				pc = ' '; // previous character
				pwh = true; // previous character is whitespace
				innl = s.IndexOf(nl); // index of next new line sequence
				iu = -1; // update i next loop, or -1
				stk = new Stack<StEl>();
				//stk.Push(new StEl { t = top, i = -1 });
				stk.Push(new StEl(top));
				//cp = Ph.READ;
				cp = "READ";
				state = State.LOADING;
			}



			// binary operators that need to be partitioned in reverse order of operations
			static readonly string[] irev =
			{
			"ASGN",
			"BOOLOR",
			"BOOLXOR",
			"BOOLAND",
			"EQ",
			"CMP",

			"BITOR",
			"BITXOR",
			"BITAND",

			"SHIFT",

			"AS",
			"MD",
		};
			void NextPh()// Phase Change
			{
				stk.Clear();
				poi++;
				cp = Phases[poi];
				StEl st = new StEl(top);
				if (irev.Contains(cp)) st.i = top.sub.Count - 1;

				stk.Push(st);
			}

			public Exception err;
			public bool LoadContinue() // LoadState st)
			{
				if (state != State.LOADING) return false;
				try
				{
					PhFns[cp]();
				}
				catch (Exception e)
				{
					err = e;
					state = State.ERR;
					//throw;
					//return false;
				}
				if (cp == "DONE") state = State.READY;
				return cp != "DONE";
			}
			public char cqd; // current quote delimiter
			public void read() // LoadState st)
			{
				// Pad with max look ahead chars
				//st.s = s = ps;
				//st_s += "    ";

				StEl st = stk.First();

				// Stage 1 - separate words and symbols

				//if (cp == Ph.READ)
				if (cp == "READ")
				//for (int i = 0; i < s.Length; i++)
				{
					//stk.First().i++;
					int i = ++st.i;
					if (i >= s.Length)
					{
						if (nest.Count > 0)
						{
							//ex("Reached end of file unexpectedly during " + cur.ty.ToString() + " block", cur);
							ex("Mismatched " + cur.ty.ToString() + " block", cur);
						}
						NextPh();

						//return true;
						return;
					}
					iu = -1;
					ch++;
					pc = c;
					c = s[i];
					pwh = isWhite(pc);
					//if (word == "@" && c != '=') { clw(); next("@", '-'); word += c; goto endc; }
					if (word == "@" && c != '=') { clw(); }
					if (c == '\"')
					{
						//if (ty == 'a') clw(); // { ex("Quotes started in the middle of a word", ln, ch); }
						clw();
						cqd = '\"';
						if (s[i + 1] == '\"' && s[i + 2] == '\"')
						{
							// Triple quote, multi line string
							cqd = 't'; // triple
							en = s.IndexOf("\"\"\"", i + 3);
							if (en == -1) { ex("Unterminated multi line string", ln, ch); }
							word = s.Substring(i + 3, en - i - 3);
							next(rEsc01(word), 'Q');
							word = "";
							// Update line/col
							lf = word.LastIndexOf('\n');
							if (lf == -1) { ch = 0; }
							else
							{
								ln += word.Count(x => x == Environment.NewLine[0]);
								ch = word.Length - lf;
							}
							iu = en + 2; // + 3;
							innl = s.IndexOf(nl, iu + 1);
						}
						else // regular quote
						{
							rEsc(i, out word, out iu);
							next(word, 'q');
						}
						ty = '?';
						word = "";
					}
					else if (c == '\'')
					{
						// single quote
						clw();
						cqd = '\'';
						rEsc(i, out word, out iu);
						next(word, 'q');

						ty = '?';
						word = "";
					}
					else if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == '_'))
					{
						if (ty == 'n')
						{
							// Hex?
							//if (c == 'x' && pc == '0' && word.Length == 1) { word += c; continue; }
							if (hex && (((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f'))))
							{
								word += c;
								return; // true; // continue;
							}
							else if ((!hex) && ((c == 'e') || (c == 'E') || (c == '+') || (c == '-')))
							{
								word += c;
								return; // true; // continue;
							}
							if ((c == 'x') && (pc == '0') && (word.Length == 1))
							{
								hex = true;
								word += c;
								return; // true; // continue; 
							}
							else ex("Number contains invalid characters");
							ex("Number contains invalid characters");
						}
						else { hex = false; }
						if (ty != 'a') { clw(); }
						word += c;
						ty = 'a';
					}
					else if (c >= '0' && c <= '9')
					{
						//if (word == "+" || word == "-") ty = 'n';
						if (ty != 'a' && ty != 'n') { clw(); }
						word += c;
						if (ty != 'a') { ty = 'n'; }
					}
					else if (pwh && c == '#')
					{
						clw();
						word += c;
						ty = 'n';
						hex = true;
					}

					else if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
					{
						// Whitespace
						clw();
						ty = ' ';
					}
					else if (c == '/' && s[i + 1] == '/')
					{
						// Line comment
						clw();
						if (innl < i) { innl = s.IndexOf(nl, i + 1); }
						iu = innl;
						if (iu == -1)
						{
							iu = s.Length;
							NextPh(); //break;
						}
						ty = ' ';
					}
					else if (c == '/' && s[i + 1] == '*')
					{
						// Delimited comment
						iu = s.IndexOf("*/", i + 2) + 1; // + 2;
						if (iu == -1)
						{
							ex("Unterminated comment", ln, ch);
							return; // false;
						}
						int cnl = s.Substring(i, iu - i).Count(x => (x == Environment.NewLine[0]));
						if (cnl > 0)
						{
							ln += cnl;
							ch = 0;
						}
						ty = ' ';
						innl = s.IndexOf(nl, iu + 1);
					}
					else if ("+-*/=!~&|^<>:@$".Contains(c))
					{
						// Some special cases for when there is no whitespace between operators that can not be a part of multi char op
						if (((c == '-') || (c == '+')) && (ty == 'n') && ((pc == 'e') || (pc == 'E')))
						{
							word += c;
							return; // true; //continue;
						}
						if (ty != '-') { clw(); }
						if ((c == '-' && pc != '-' && !pwh) || (c == '+' && pc != '+' && !pwh)) clw();

						ty = '-';
						if (c == '$') { clw(); next("$", '-'); goto endc; }
						//if (pc == '@' && c != '=') { clw(); next("@", '-'); goto endc; }
						//if (c == '@') { clw(); next("@", '-'); goto endc; }
						word += c;
					}
					else if (c == ';')
					{
						clw();
						next(";", ';');
					}
					else if (c == ',')
					{
						clw();
						next(",", ',');
					}
					else if (c == '.')
					{
						if (ty == 'n')
						{
							word += c;
						}
						else
						{
							clw();
							// Cheating, read ahead
							if (s[i + 1] >= '0' && s[i + 1] <= '9')
							{
								word = ".";
								ty = 'n';
							}
							else next(".", '.');
						}
					}
					else
					{
						if (word.Length > 0) { clw(); }
						next(c.ToString(), '?');
						ty = c;
					}

				endc:

					// Check for end of line
					if (iu == -1) { iu = i; }
					if (iu == innl)
					{
						innl = s.IndexOf(nl, iu + 1);
						ln++;
						ch = 0;
					}
					st.i = iu;

				} // for (int i = 0; i < s.Length; i++)
			} // read()

			public bool IsDone() { return cp == "DONE"; }

			void clw() { hex = false; if (word.Length > 0) { next(word, ty); word = ""; ty = '?'; } }
			void next(string w) { next(w, ty); }
			void next(string w, char ty)
			{
				if (w.Length == 0 && ty != 'q') return;
				Token nt = new Token { ln = ln, ch = ch, m = cqd }; // TODO: -1 ?
				if (ty != '?')
				{
					nt.con = w;
					nt.ty = ty;
					cur.sub.Add(nt);
					return;
				}
				switch (w)
				{
					case "{":
						nt.ty = '{';
						cur.sub.Add(nt);
						nest.Push(cur);
						cur = nt;
						break;
					case "}":
						if (cur.ty != '{') { ex("Unmatched }"); }
						cur = nest.Pop();
						break;
					case "[":
						nt.ty = '[';
						cur.sub.Add(nt);
						nest.Push(cur);
						cur = nt;
						break;
					case "]":
						if (cur.ty != '[') { ex("Unmatched ]"); }
						cur = nest.Pop();
						break;
					case "(":
						nt.ty = '(';
						cur.sub.Add(nt);
						nest.Push(cur);
						cur = nt;
						break;
					case ")":
						if (cur.ty != '(') { ex("Unmatched )"); }
						cur = nest.Pop();
						break;
					default:
						if (ty == '?')
						{
							nt.ty = 'a';
						}
						else { nt.ty = ty; }
						nt.con = w;
						cur.sub.Add(nt);
						break;
				} // switch (w)
				  //return true;
			} // next()

			void rEsc(int beg, out string ret, out int endPos)
			{
				ret = "";
				char ec = s[beg]; // end char
				char c;
				int i = beg;
				i++;
				int ch0 = ch;
				while (true)
				{
					if (i >= s.Length) { ex("Reached end of file inside quotes"); }
					ch = ch0 + i - beg;
					c = s[i];

					if (c == '\\')
					{
						switch (s[i + 1])
						{
							case '\'':
								ret += '\'';
								i += 2;
								break;
							case '\"':
								ret += '\"';
								i += 2;
								break;
							case 't':
								ret += '\t';
								i += 2;
								break;
							case 'r':
								ret += '\r';
								i += 2;
								break;
							case 'n':
								ret += '\n';
								i += 2;
								break;
							case 'a':
								ret += '\a';
								i += 2;
								break;
							case 'b':
								ret += '\b';
								i += 2;
								break;
							case 'f':
								ret += '\f';
								i += 2;
								break;
							case 'v':
								ret += '\v';
								i += 2;
								break;
							case '\\':
								ret += '\\';
								i += 2;
								break;
							case 'x':
								ret += (char)Convert.ToUInt16(s.Substring(i + 2, 2), 16);
								i += 4;
								break;
							case 'u':
								ret += (char)Convert.ToUInt16(s.Substring(i + 2, 4), 16);
								break;
							case '0':
								ret += '\0';
								i += 2;
								break;
							default:
								ex("Unknown string escape sequence");
								break;
						}
					}
					else if (c == '\r' || c == '\n')
					{
						ex("Reached end of line during quotes (Use triple quotes for multi line strings)");
					}
					else if (c == ec) { break; }
					else
					{
						ret += c;
						i++;
					}
				}
				endPos = i;
				//ret = s.Substring(beg + 1, i - beg - 1);
			} // rEsc()



			string rEsc01(string w)
			{
				string ret = "";
				int i = 0;
				int i2 = -1;
				do
				{
					i2 = w.IndexOf('\\', i);
					if (i2 != -1)
					{
						ret += w.Substring(i, i2 - i);
						i = i2;
						switch (w[i2 + 1])
						{
							case '\'':
								ret += '\'';
								i += 2;
								break;
							case '\"':
								ret += '\"';
								i += 2;
								break;
							case 't':
								ret += '\t';
								i += 2;
								break;
							case 'r':
								ret += '\r';
								i += 2;
								break;
							case 'n':
								ret += '\n';
								i += 2;
								break;
							case 'a':
								ret += '\a';
								i += 2;
								break;
							case 'b':
								ret += '\b';
								i += 2;
								break;
							case 'f':
								ret += '\f';
								i += 2;
								break;
							case 'v':
								ret += '\v';
								i += 2;
								break;
							case '\\':
								ret += '\\';
								i += 2;
								break;
							case 'x':
								ret += (char)Convert.ToUInt16(w.Substring(i + 2, 2), 16);
								i += 4;
								break;
							case 'u':
								ret += (char)Convert.ToUInt16(w.Substring(i + 2, 4), 16);
								break;
							case '0':
								ret += '\0';
								i += 2;
								break;
						} // switch
					} // if found
				} while (i2 != -1 && i < w.Length);
				ret += w.Substring(i, w.Length - i);
				return ret;
			} // resc01()

			void Statements() //Token t) //, Token p, int ipar)
			{
				// TODO: Some semicolons may already be condensed as a result of tkUntilSsemi().
				//       So, test for sub contents.
				//foreach (var s in t.sub) { condenseStatements(s, p); }
				StEl st = stk.First();
				Token t = st.t;
				if (st.i < 0) st.i = 0;
				if (st.pi < 0) st.pi = 0; // previous index
				int i = st.i;
				//int beg = 0;
				int beg = Math.Max(st.pi, 0);
				Token si;

				//for (int i = 0; i < t.sub.Count; i++)
				if (i < t.sub.Count)
				{
					//condenseStatements(t.sub[i]); //, t, i);
					si = t.sub[i];
					if (st.ph == 0)
					{
						st.ph = 1;
						stk.Push(new StEl(si));
					}
					else if (st.ph == 1)
					{
						Token nt;
						if (si.ty == ';' && si.sub.Count == 0)
						{
							nt = mknt(';', si);
							for (int m = beg; m < i; m++)
							{
								nt.sub.Add(t.sub[m]);
							}
							t.sub.RemoveRange(beg, i - beg + 1);
							t.sub.Insert(beg, nt);
							st.i = beg;
							//beg++;
							st.pi++;
						}
						//else if ((si.ty == '-' && si.con == ":") || si.ty == '{')
						//else if ((si.ty == '-' && si.con == ":") || "{iwfdsu".Contains(si.ty))
						else if ("{iwfdsu".Contains(si.ty) && i == beg)
						{
							// Skip over blocks
							st.pi = i + 1;
						}
						else if ((si.ty == '-' && si.con == ":"))
						{
							// Labels
							//!TEST disabling this
							// !CURRENT
							// TODO: Difference between x = function(){} and just function(){} ... any other tokens since last beg?
							st.pi = i + 1;
						}
						else if ("{iwfdsu".Contains(si.ty) && i == beg + 1)
						{
							// If we're exactly one element after a function, while, for, do, or {} block,
							// it means that previous element is a standalone token and we need to start
							// over with a new statement, setting the begin token marker to here+1.
							st.pi = i + 1;
							// Otherwise, the block is part of a larger statement, keep collecting tokens
							// for the next ;
						}
						////else if ("{[(".Contains(t.sub[i].ty)) { beg = i + 1; }
						//else if (si.ty == '{')
						//{
						//	//beg = i + 1;
						//	st.iPrev = i + 1;
						//}

						st.ph = 0;
						st.i++;
					}
				}
				else
				{
					stk.Pop();
					if (stk.Count == 0) NextPh();
				}
			}


			Token mknt(char ty, int ln, int ch) { return new Token { ty = ty, ln = ln, ch = ch }; }
			Token mknt(char ty, Token pos) { return mknt(ty, pos.ln, pos.ch); }
			void mv(Token src, int idx, Token dest)
			{
				dest.sub.Add(src.sub[idx]);
				src.sub.RemoveAt(idx);
			}
			void rm(Token t, int idx) { t.sub.RemoveAt(idx); }

			void index()
			{
				StEl st = stk.First();
				if (st.i < 0) st.i = 0;
				if (st.i < st.t.sub.Count)
				{
					Token si = st.t.sub[st.i];
					si.p = st.t;
					//si.p.SetTarget(st.t);
					si.idx = st.i;

					// promote functions and labels to their proper containers (function or top)
					Token tg;
					if (si.ty == ':')
					{
						tg = st.t;
						while (tg.p != null && !"uT".Contains(tg.ty)) { tg = tg.p; }
						//while (tg.p != null && !"uT".Contains(tg.ty)) { if (!tg.p.TryGetTarget(out tg)) ex("Token life cycle error"); }
						if (tg.lbls != null && tg.lbls.ContainsKey(si.con)) ex("Duplicate label", si);
						if (tg.lbls == null) tg.lbls = new Dictionary<string, Token>();
						tg.lbls[si.con] = si;
					}
					else if (si.ty == 'u')
					{
						tg = st.t;
						while (tg.p != null && !"uT".Contains(tg.ty)) { tg = tg.p; }
						//while (tg.p != null && !"uT".Contains(tg.ty)) { if (!tg.p.TryGetTarget(out tg)) ex("Token life cycle error"); }
						if (tg.fns != null && tg.fns.ContainsKey(si.con)) ex("Function name already defined", si);
						if (tg.fns == null) tg.fns = new Dictionary<string, Token>();
						tg.fns[si.con] = si;
					}

					st.i++;
					stk.Push(new StEl(si));
				}
				else
				{
					stk.Pop();
					if (stk.Count == 0) NextPh();
				}
			}

			char sty(Token t, int i) // sub type
			{
				if (i >= t.sub.Count || i < 0) return '?';
				return t.sub[i].ty;
			}

			Token tkUntilSemi(Token t, int iStart, char containerType = '{')
			{
				Token r = mknt(containerType, t.sub[iStart]);
				int i;
				//for (i = iStart; i < t.sub.Count && t.sub[i].ty != ';'; i++) { r.sub.Add(t.sub[i]); }
				for (i = iStart; i < t.sub.Count; i++)
				{
					r.sub.Add(t.sub[i]);
					if (t.sub[i].ty == ';') break;
				}
				if (i >= t.sub.Count || t.sub[i].ty != ';') ex("Missing a ;");
				t.sub.RemoveRange(iStart, i - iStart + 1);
				return r;
			}

			bool touch(Token t)
			{
				if (t.touched >= poi) return false;
				t.touched = poi;
				return true;
			}
			void Flow()
			{
				var st = stk.First();
				Token t = st.t;
				int cn = t.sub.Count;
				if (st.i < 0) st.i = 0;
				int i = st.i;

				if (i >= cn) goto breakCF;
				//else if (!st.rf)
				Token si = t.sub[i];

				if (st.ph == 0)
				{
					//stk.Push(new StEl { t = t.sub[i] });
					st.ph = 1;
					stk.Push(new StEl(t.sub[i]));
					return;
				}

				//for (int i = 0; i < t.sub.Count; i++)
				else if (st.ph == 1)
				{
					//condenseFlow(t.sub[i]);
					//if (i >= t.sub.Count) goto breakCF; //break;
					Token si1 = (i + 1 < cn) ? t.sub[i + 1] : null;
					Token si2 = (i + 2 < cn) ? t.sub[i + 2] : null;
					Token si3 = (i + 3 < cn) ? t.sub[i + 3] : null;
					Token tki, tkc, tke, tkf, tkw, tkd, tkn, tkp, tks, tkr;
					// ^ if, condition, else, for, while, do, not, parentheses, semicolon
					if (si.ty == 'a')
					{
						switch (si.con.ToLower())
						{
							case "if":
								if (si1 == null || si1.ty != '(') ex("'if' expects '('", si);
								tki = mknt('i', si);
								tkc = mknt('c', si1);
								tki.sub.Add(tkc);
								rm(t, i); // "if"
								mv(t, i, tkc); // ()
								if (si2 != null && si2.ty == '{')
								{
									mv(t, i, tkc);
								}
								else
								{
									tkc.sub.Add(tkUntilSemi(t, i));
								}
								t.sub.Insert(i, tki);
								st.i--;
								break;

							case "else":
								if ((i - 1 < 0) || (t.sub[i - 1].ty != 'i')) { ex("'else' missing 'if'", si); }
								tki = t.sub[i - 1];
								if (si1.ty == 'a' && si1.con == "if")
								{
									// "else if"
									if (si2 == null || si2.ty != '(') ex("'else if' expects a (", si);
									if (si3 == null) ex("no block after 'else if'", si);
									tkc = mknt('c', si);
									rm(t, i); // "else"
									rm(t, i); // "if"
									mv(t, i, tkc); // ()
									if (si3.ty == '{')
									{
										mv(t, i, tkc);
									}
									else
									{
										tkc.sub.Add(tkUntilSemi(t, i));
									}
									tki.sub.Add(tkc);
								}
								else
								{
									// just plain 'else'
									tke = mknt('e', si);
									tki.sub.Add(tke);
									rm(t, i); // "else"
									if (si1.ty == '{')
									{
										mv(t, i, tke);
									}
									else
									{
										tke.sub.Add(tkUntilSemi(t, i));
									}
								}
								st.i--;
								break;
							case "while":
								if (si1 == null || si1.ty != '(') ex("'while' expects a (", si);
								if (si2 == null) ex("no statement after 'while'", si);
								tkw = mknt('w', si);
								rm(t, i);
								mv(t, i, tkw);
								if (t.sub[i].ty == '{')
								{
									mv(t, i, tkw);
								}
								else
								{
									tkw.sub.Add(tkUntilSemi(t, i));
								}
								t.sub.Insert(i, tkw);
								st.i--;
								break;
							case "for":
								//ex("'for' is unsupported at this time", si);
								if (si1 == null || si1.ty != '(') ex("'for' expects a (", si);
								if (si2 == null) ex("no statement after 'for'", si);
								tkf = mknt('f', si);
								rm(t, i);
								tkp = t.sub[i];
								if (tkp.sub.Count == 0) ex("Malformed 'for' statement", tkp);
								tks = tkp.sub[tkp.sub.Count - 1];
								tkp.sub.Add(mknt(';', tks));
								mv(t, i, tkf);
								if (si2.ty == '{') mv(t, i, tkf);
								else tkf.sub.Add(tkUntilSemi(t, i));
								t.sub.Insert(i, tkf);
								st.i--;
								break;
							case "do":
								if (si1 == null) ex("Malformed 'do' statement");
								tkd = mknt('d', si);
								rm(t, i);
								if (si1.ty == '{') mv(t, i, tkd);
								else tkd.sub.Add(tkUntilSemi(t, i));
								if (i + 1 >= t.sub.Count) ex("'do' block must be followed by a 'while' or 'until' condition", tkd);
								si = t.sub[i];
								si1 = t.sub[i + 1];
								if (si.con == "while")
								{
									rm(t, i);
									si = t.sub[i];
									if (si.ty != '(') ex("'while' must be followed by a () condition", si);
									tkc = mknt('c', si);
									mv(t, i, tkc);
									//tkd.sub.Insert(i, tkc);
									tkd.sub.Add(tkc);
								}
								else if (si2.con == "until")
								{
									rm(t, i);
									si = t.sub[i];
									if (si.ty != '(') ex("'until' must be followed by a () condition", si);
									tkc = mknt('c', si);
									tkn = mknt('-', si);
									tkn.con = "!";
									mv(t, i, tkn);
									tkc.sub.Add(tkn);
									//t.sub.Insert(i, tkc);
									tkd.sub.Add(tkc);
								}
								else ex("'do' block must be followed by a 'while' or 'until' condition", si);
								//ex("'do' is unsupported at this time", si);
								t.sub.Insert(i, tkd);
								st.i--;
								break;
							case "function":
							case "func":
								string fname;
								int cc = 3; // consume count
								if (si1 == null || si1.ty != 'a')
								{
									cc = 2;
									fname = "fn" + (nextRandomId++).ToString();
									si3 = si2;
									si2 = si1;
								}
								else fname = si1.con;
								if (si2 == null || si2.ty != '(') ex("'function' missing parameter list () ", si);
								if (si3 == null || si3.ty != '{') ex("'function' mising body", si);
								si.ty = 'u';
								si.con = fname;
								si.sub.Clear();
								si.sub.Add(si2);
								si.sub.Add(si3);
								t.sub.RemoveRange(i + 1, cc);
								stk.Push(new StEl(si3));
								break;
							case "return":
								//if (i != 0) ex("'return' must be the first word in a statement (forget a ; ?)", si);
								tkr = tkUntilSemi(t, i + 1, 'R');
								tks = mknt(';', tkr.sub[tkr.sub.Count - 1]);
								tks.sub.Add(tkr);
								tkr.sub.RemoveAt(tkr.sub.Count - 1);
								t.sub[i] = tks;
								stk.Push(new StEl(tkr));
								//si.ty = 'R';
								//si.sub.Add(tks);
								//t.sub.Insert(i, tks);
								break;
							// Note: "var" can be shoved down the tree after operators are partitioned
							case "wait": // wait x seconds
										 //DateTime.Now.ToBinary();
								tkr = tkUntilSemi(t, i + 1, 'A');
								if (tkr.sub.Count > 0 && tkr.sub[tkr.sub.Count - 1].ty == ';') tkr.sub.RemoveAt(tkr.sub.Count - 1);
								else ex("Missing ;", si);

								si.ty = ';';
								//si.con = ";";
								//si.sub.Add(tkr);
								//t.sub.RemoveAt(i);
								t.sub.Insert(i, tkr);
								stk.Push(new StEl(tkr));
								break;
							case "watch":
								//ty = 'I';
								if (si1 == null || si1.ty != '(') ex("Expected: '('", si);
								if (si2 == null) ex("Missing statement ; or control block {}");
								tkw = mknt('I', si);
								rm(t, i);
								mv(t, i, tkw);
								//si.ty = 'I';
								if (t.sub[i].ty == '{')
								{
									mv(t, i, tkw);
								}
								else
								{
									tkw.sub.Add(tkUntilSemi(t, i));
								}
								t.sub.Insert(i, tkw);
								st.i--;
								//stk.Push(new StEl(si));
								break;
							case "unwatch":
								ty = 'J'; // because J comes after I, you watch, then you unwatch. Letters are starting to become scarce, have to get creative here
								tkr = tkUntilSemi(t, i + 1, 'J');
								si.ty = ';';
								tkr.sub.RemoveAt(tkr.sub.Count - 1);
								//si.sub.Add(tkr);
								t.sub.Insert(i, tkr);
								stk.Push(new StEl(tkr));
								break;
							case "exit":
								// TODO: exit
								ty = 'X';
								tkr = tkUntilSemi(t, i + 1, 'X');
								tkr.sub.RemoveAt(tkr.sub.Count - 1); // remove semicolon
								t.sub.RemoveAt(i);
								t.sub.Insert(i, tkr);
								//si.ty = 'X';
								//si.sub.Add(tkr);
								stk.Push(new StEl(tkr));
								break;
							//case "on":
							//	// idk... maybe leave that up to the system launching it to set the display
							//	break;
							case "import":
							case "run":
								ty = 'M';
								tkr = tkUntilSemi(t, i + 1, 'M');
								tks = tkr.sub[tkr.sub.Count - 1];
								tkr.sub.RemoveAt(tkr.sub.Count - 1);
								tkr.con = si.con;
								t.sub.RemoveAt(i);
								t.sub.Insert(i, mknt(';', tks));
								t.sub.Insert(i, tkr);
								stk.Push(new StEl(tkr));
								break;
						}
					}

					st.ph = 0;
					st.i++;
				} // ph 1
				else ex("Parsing error: flow phase", si);

				return;
			breakCF:
				stk.Pop();
				if (stk.Count == 0) NextPh();
			} // condenseFlow()

			void bop(string ops, string tys = " - ") // splits a - b into left and right operands in sub of -
			{
				StEl st = stk.First(); //.Last();
				Token t = st.t;
				if (st.i < 0) goto breakOP; // st.i = 0;
				int i = st.i;
				Token si, tkl, tkr;
				//for (int i = t.sub.Count - 1; i >= 0; i--)

				if (t == null) goto breakOP;

				if (i < t.sub.Count)
				{
					si = t.sub[i];
					//opSplit(si, ops);
					if (st.ph == 0)
					{
						st.ph = 1;
						//stk.Push(new StEl(si));
						StEl pst = new StEl(si);
						pst.i = si.sub.Count - 1;
						stk.Push(pst);
					}
					else if (st.ph == 1 && tys.Contains(" " + si.ty + " ") && ops.Contains(" " + si.con + " ") && touch(si))
					{
						tkl = mknt('l', si);
						tkr = mknt('r', si);
						//for (int il = 0; il < i; il++) { mv(t, 0, tkl); }
						//while (t.sub.Count > 1) { mv(t, 1, tkr); }
						tkl.sub.AddRange(t.sub.GetRange(0, i));
						tkr.sub.AddRange(t.sub.GetRange(i + 1, t.sub.Count - i - 1));
						int rmStart = 0;
						if (tkl.sub.Count == 0 || (t.sub.Count > i - 1 && t.sub[i - 1].ty == '-'))
						{
							if (si.con == "+" || si.con == "-")
							{
								Token tk0 = mknt('n', si);
								tk0.con = "0";
								tkl = mknt('l', si);
								tkl.sub.Add(tk0);
								rmStart = i;
							}
							else ex("Missing left operand", si);
						}
						if (tkr.sub.Count == 0) ex("Missing right operand");
						//else
						{
							si.ty = '-';
							si.sub.Add(tkl);
							si.sub.Add(tkr);
							//t.sub.Clear();
							t.sub.RemoveRange(rmStart, t.sub.Count - rmStart);
							t.sub.Add(si);
							st.ph = 2;
							st.i = -1;
							StEl pst = new StEl(si);
							pst.i = si.sub.Count - 1;
							stk.Push(pst);
						}
					}

					else if (st.ph == 2)
					{
						st.ph = 3;
						stk.Push(new StEl(si.sub[0]));
					}
					else if (st.ph == 3)
					{
						st.ph = 4;
						stk.Push(new StEl(si.sub[1]));
					}
					//else if (st.ph == 4) goto breakOP;
					else
					{
						st.ph = 0;
						//st.i++;
						st.i--;
					}
				}
				else
				{
					goto breakOP;
				}
				return;
			breakOP:
				stk.Pop();
				if (stk.Count == 0) NextPh();
			} // opSplit()

			// Unary operator
			void uop(string ops, string tys = " - ", bool greedy = false)
			{
				StEl st = stk.First(); //.Last();
				Token t = st.t;
				if (st.i < 0) st.i = 0;
				int i = st.i;
				int cn = t.sub.Count;
				Token si, tkl, tkr, tko;
				string con;
				//for (int i = t.sub.Count - 1; i >= 0; i--)

				if (i >= cn) goto breakUOP;
				si = t.sub[i];
				if (st.ph == 0)
				{
					st.ph++;
					stk.Push(new StEl(si));
				}
				else if (st.ph == 1)
				{
					tkl = null;
					if (tys.Contains(" " + si.ty + " ") && ops.Contains(" " + si.con + " "))
					{
						if (cn <= i + 1) ex("Missing operand", si);
						tkl = mknt('l', si);
						tkr = mknt('r', si);
						con = si.con;
						if (greedy)
						{
							t.sub.RemoveAt(i);
							tkr.sub.AddRange(t.sub);
							t.sub.Clear();
							tko = mknt('-', si);
							tko.con = con;
							t.sub.Add(tko);
						}
						else
						{
							if (i >= cn - 1) { ex("$ missing operand"); }
							tkr.sub.Add(t.sub[i + 1]);
							tko = si;
							t.sub.RemoveAt(i + 1);
						}
						tko.ty = '-';
						tko.con = con;
						tko.sub.Clear();
						tko.sub.Add(tkl);
						tko.sub.Add(tkr);
					}
					st.ph = 0;
					st.i++;
				}

				return;
			breakUOP:
				stk.Pop();
				if (stk.Count == 0) NextPh();
			}

			void Commas() // Token t)
			{
				StEl st = stk.First();
				Token t = st.t;
				//if (st.ph == 0) { st.i++; }
				if (st.i < 0) st.i = 0;
				int i = st.i;
				Token si, tkp;
				si = tkp = null;
				//if (st.tk == null) st.tk = new Dictionary<char, Token>();
				//if (st.tk.ContainsKey('c')) tkc = st.tk['c'];
				//tkc = st.tkc;
				int iPrev = st.pi; // -1;
								   //for (int i = 0; i < t.sub.Count; i++)
				if (i < t.sub.Count)
				{
					si = t.sub[i];
					//condenseCommas(si);
					if (st.ph == 0)
					{
						st.ph = 1;
						stk.Push(new StEl(si));
					}
					else if (st.ph == 1)
					{
						if (si.ty == ',')
						{
							if (st.tkc == null) { st.tkc = mknt(',', t); }
							tkp = mknt('(', si);
							tkp.sub.AddRange(t.sub.GetRange(iPrev + 1, i - iPrev - 1));
							//t.sub.RemoveRange(iPrev + 1, i - iPrev);
							//i--;
							st.tkc.sub.Add(tkp);
							st.pi = iPrev = i;
						}
						st.i++;
						st.ph = 0;
					}
				}
				else goto breakCM;

				//if (tkc != null) st.tk['c'] = tkc;
				return;

			breakCM:
				if (st.tkc != null)
				{
					tkp = mknt('(', st.tkc);
					tkp.sub.AddRange(t.sub.GetRange(iPrev + 1, t.sub.Count - iPrev - 1));
					st.tkc.sub.Add(tkp);
					t.sub.Clear();
					t.sub.Add(st.tkc);
				}
				stk.Pop();
				if (stk.Count == 0) NextPh();
			} // condenseCommas

			void labels()
			{
				StEl st = stk.First();
				Token t = st.t;
				if (st.i < 0) st.i = 0;
				int i = st.i;
				if (i < t.sub.Count)
				{
					Token si = t.sub[i];
					if (st.ph == 0)
					{
						st.ph = 1;
						stk.Push(new StEl(si));
					}
					else if (st.ph == 1)
					{
						if (si.ty == '-' && si.con == ":" && i > 0 && t.sub[i - 1].ty == 'a')
						//if (si.ty == '-' && si.con == ":")
						{
							//if (i < 1 || t.sub[i - 1].ty != 'a') ex("No identifier preceding : for label", si);
							if ((i == 1) || ((i > 1) && ((t.sub[i - 2].ty == ';') || (t.sub[i - 2].ty == '{'))))
							{
								si.ty = ':';
								si.con = t.sub[i - 1].con;
								//if (lbl.ContainsKey(si.con)) ex("Duplicate label", si);
								//Token ltg = t; //label target
								//while (ltg != null && !"uT".Contains(ltg.ty)) { ltg = }
								//if (t.lbls.ContainsKey(si.con)) ex("Duplicate label", si);
								//lbl[si.con] = si;
								t.sub.RemoveAt(i - 1);
							}
						}
						st.ph = 0;
						st.i++;
					}
					else ex("Internal error: Bad label phase", si);
				}
				else
				{
					goto breakLbl;
				}
				return;
			breakLbl:
				stk.Pop();
				if (stk.Count == 0) NextPh();
			}

			void sign()
			{
				StEl st = stk.First();
				Token t = st.t;
				if (st.i < 0) st.i = 0;
				int i = st.i;
				Token sim1 = null, si1 = null;
				bool sg = false;
				if (i < t.sub.Count)
				{
					if (i > 0) sim1 = t.sub[i - 1];
					if (i + 1 < t.sub.Count) si1 = t.sub[i + 1];
					Token si = t.sub[i];
					if (si.ty != '-' || (si.con != "+" && si.con != "-")) goto nxi;
					if (sim1 == null && si1 != null) sg = true;
					else if (sim1.ty == '-' && si1 != null) sg = true;
					if (sg)
					{
						t.sub.RemoveAt(i);
						si1.con = si.con + si1.con;
						st.i--;
					}

				}
				else
				{
					stk.Pop();
					if (stk.Count == 0) NextPh();
					return;
				}
			nxi:
				st.ph = 0;
				st.i++;
			}

		} // class Tokenizer











































		#region Visual Studio Setup

	} // class Program
} // namespace
#endregion // VS
